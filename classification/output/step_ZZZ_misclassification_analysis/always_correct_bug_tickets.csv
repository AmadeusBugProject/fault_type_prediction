,doc,url,correct,target,prediction,count
81,"Deadlock can happen when MemoryAwareThreadPoolExecutor with limit is used
I believe that I have found a deadlock on Netty 3.6.5.Final. It seems that ""New I/O worker #2"" thread fires an event while it is holding a lock (AbstractNioWorker.java:343 - channel.writeLock). It waits on a MemoryAwareThreadPoolExecutor$Limiter (because the available space has been exceeded) instance but the ""OrderedMemoryAwareThreadPoolExecutor thread #3"" can not notify it because ""New I/O worker #2"" is holding the lock ""OrderedMemoryAwareThreadPoolExecutor thread #3"" requires to continue processing its requests.

Here are the stack traces:

```
""New I/O worker #2"" prio=6 tid=0x16f1f800 nid=0x9d0 in Object.wait() [0x1758f000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:503)
    at org.jboss.netty.handler.execution.MemoryAwareThreadPoolExecutor$Limiter.increase(MemoryAwareThreadPoolExecutor.java:640)
    - locked <0x080da358> (a org.jboss.netty.handler.execution.MemoryAwareThreadPoolExecutor$Limiter)
    at org.jboss.netty.handler.execution.MemoryAwareThreadPoolExecutor.increaseCounter(MemoryAwareThreadPoolExecutor.java:501)
    at org.jboss.netty.handler.execution.MemoryAwareThreadPoolExecutor.execute(MemoryAwareThreadPoolExecutor.java:435)
    at org.jboss.netty.handler.execution.ExecutionHandler.handleUpstream(ExecutionHandler.java:173)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
    at org.jboss.netty.handler.codec.oneone.OneToOneDecoder.handleUpstream(OneToOneDecoder.java:60)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
    at org.jboss.netty.channel.SimpleChannelUpstreamHandler.channelUnbound(SimpleChannelUpstreamHandler.java:216)
    at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:95)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
    at org.jboss.netty.channel.Channels.fireChannelUnbound(Channels.java:432)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.close(AbstractNioWorker.java:343)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:254)
    - locked <0x08454ce0> (a java.lang.Object)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromTaskLoop(AbstractNioWorker.java:150)
    at org.jboss.netty.channel.socket.nio.AbstractNioChannel$WriteTask.run(AbstractNioChannel.java:335)
    at org.jboss.netty.channel.socket.nio.AbstractNioSelector.processTaskQueue(AbstractNioSelector.java:366)
    at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:290)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:88)
    at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)
    at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)
    at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
    at java.lang.Thread.run(Unknown Source)

   Locked ownable synchronizers:
    - <0x080c36d0> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""OrderedMemoryAwareThreadPoolExecutor thread #3"" prio=6 tid=0x16ef8800 nid=0x914 waiting for monitor entry [0x17f8e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.cleanUpWriteBuffer(AbstractNioWorker.java:374)
    - waiting to lock <0x08454ce0> (a java.lang.Object)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:127)
    at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
    at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
    at org.jboss.netty.handler.ssl.SslHandler.flushPendingEncryptedWrites(SslHandler.java:1109)
    at org.jboss.netty.handler.ssl.SslHandler.wrap(SslHandler.java:1048)
    at org.jboss.netty.handler.ssl.SslHandler.handleDownstream(SslHandler.java:631)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:784)
    at org.jboss.netty.channel.Channels.write(Channels.java:725)
    at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
    at org.jboss.netty.handler.codec.oneone.OneToOneStrictEncoder.doEncode(OneToOneStrictEncoder.java:35)
    - locked <0x083e9968> (a org.jboss.netty.channel.socket.nio.NioAcceptedSocketChannel)
    at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
    at org.jboss.netty.handler.codec.compression.JdkZlibEncoder.handleDownstream(JdkZlibEncoder.java:221)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:784)
    at org.jboss.netty.handler.execution.ExecutionHandler.handleDownstream(ExecutionHandler.java:186)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:784)
    [my project's classes...]
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
    at org.jboss.netty.channel.Channels.write(Channels.java:704)
    at org.jboss.netty.channel.Channels.write(Channels.java:671)
    at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
    [my project's classes...]
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
    at org.jboss.netty.channel.Channels.write(Channels.java:704)
    at org.jboss.netty.channel.Channels.write(Channels.java:671)
    at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
    [my project's classes...]
    - locked <0x083db908> ([my project's classes...])
    [my project's classes...]
    at org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:88)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
    at org.jboss.netty.handler.execution.ChannelUpstreamEventRunnable.doRun(ChannelUpstreamEventRunnable.java:43)
    at org.jboss.netty.handler.execution.ChannelEventRunnable.run(ChannelEventRunnable.java:67)
    at org.jboss.netty.handler.execution.OrderedMemoryAwareThreadPoolExecutor$ChildExecutor.run(OrderedMemoryAwareThreadPoolExecutor.java:314)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
    at java.lang.Thread.run(Unknown Source)

   Locked ownable synchronizers:
    - <0x083d62a8> (a java.util.concurrent.ThreadPoolExecutor$Worker)
    - <0x0841d6a8> (a java.util.concurrent.locks.ReentrantLock$FairSync)
    - <0x0841e978> (a java.util.concurrent.locks.ReentrantLock$FairSync)
    - <0x0841ea10> (a java.util.concurrent.locks.ReentrantLock$FairSync)
```
",https://github.com/netty/netty/issues/1310,1.0,0.0,0.0,49
448,"_missing_ is missing?
`_missing_` doesn't appear to have made it into 5.0 (it's in the [2.4 docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html)), but it's not in the [breaking changes](https://www.elastic.co/guide/en/elasticsearch/reference/5.0/breaking_50_search_changes.html).

Was this removed?",https://github.com/elastic/elasticsearch/issues/21226,1.0,2.0,2.0,45
270,"OioSocketChannel.close(...) and OioDatagramChannel.close(...) may interrupt wrong thread
Because of a race-condition it is possible that OioSocketChannel.close(...) / OioDatagramChannel.close(...) will interrupt the wrong thread.
",https://github.com/netty/netty/issues/2013,1.0,0.0,0.0,54
289,"Possible race-condition during write operation cancellation
",https://github.com/redisson/redisson/issues/1061,1.0,0.0,0.0,44
172,"Infinity-loop in HashedWheelTimer
From mailinglist: 

Hello, guys,

I am not sure if I have hit upon a regression in HashedWheelTimer or MpscLinkedQueue, or I am using the classes in an improper way. I occassionally see a timer thread stuck in an infinite loop in peekNode(), 100% CPU (see stack trace right at the end).

I am running 4.0.21.Final, substantially same code was running several 4.0.x versions without seeing this.

Debugging the thread, MpscLinkedQueue.peekNode(): head of the queue is a not null cancelled timer, next is null, tail is a not null cancelled timer.

Suggestions?

""timer-5-thread-1"" prio=10 tid=0x00007f12b8075800 nid=0x24b5 runnable [0x00007f12f60f7000]
   java.lang.Thread.State: RUNNABLE
    at io.netty.util.internal.MpscLinkedQueue.peekNode(MpscLinkedQueue.java:114)
    at io.netty.util.internal.MpscLinkedQueue.poll(MpscLinkedQueue.java:139)
    at io.netty.util.HashedWheelTimer$Worker.transferTimeoutsToBuckets(HashedWheelTimer.java:387)
    at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:362)
    at java.lang.Thread.run(Thread.java:744)
   Locked ownable synchronizers:
    - None
",https://github.com/netty/netty/issues/2651,1.0,0.0,0.0,41
422,"WebSocketRegistryListener leaks if no SessionDestroyedEvent fired
If no SessionDestroyedEvent is fired, then WebSocketRegistryListener will have a memory leak. This would happen if Redis is not configured to send events.

We should be proactive in ensuring that Redis is configured for send session expiration events (which then get translated to SessionDestroyedEvent). We should also ensure empty session to WebSocket connections are removed.
",https://github.com/spring-projects/spring-session/issues/76,1.0,1.0,1.0,45
150,"GrizzlyResponse object reachable from SelectorRunner thread local
Hi,

We are using grizzly through AHC to perform some HTTP requests. After those requests have finished, in a thread dump i can still see the response objects being referenced, and not being garbage collected. Attached is a screenshot of there references from a heap dump:

![screen shot 2015-12-22 at 9 37 37 am](https://cloud.githubusercontent.com/assets/8010105/11955732/211f42b4-a893-11e5-8885-4c7eb7553764.png)

In a case where the size of the transferred data is big, i see some heavy memory usage.

The problem seems to be with the reference chain TCPNIOConnection -> IndexedAttributeHolder -> $Snapshot -> HttpTransactionContext. Perhaps at least one of those references should be discarded after the request has completed, or provide a way to an app to clear that.

The following test can reproduce this issue.

```
    @Test
    public void referencedResponseHC() throws InterruptedException
    {
        AsyncHttpClientConfig config = new AsyncHttpClientConfig.Builder().build();
        AsyncHttpClient client = new AsyncHttpClient(new GrizzlyAsyncHttpProvider(config), config);

        final CountDownLatch responseLatch = new CountDownLatch(1);
        final AtomicReference<Response> responseRef = new AtomicReference<>();

        client.prepareGet(""http://www.ning.com/"").execute(new AsyncCompletionHandler<Response>()
        {

            @Override
            public Response onCompleted(Response response) throws Exception
            {
                responseLatch.countDown();
                responseRef.set(response);
                return response;
            }

            @Override
            public void onThrowable(Throwable t)
            {
                // Something wrong happened.
            }
        });

        responseLatch.await(5, TimeUnit.SECONDS);
        verifyNotLeaked(new PhantomReference<>(responseRef.getAndSet(null), new ReferenceQueue<>()));
    }

    private void verifyNotLeaked(PhantomReference possibleLeakPhantomRef) throws InterruptedException
    {
        for (int i = 0; i < 10; ++i)
        {
            System.gc();
            Thread.sleep(100);
            if (possibleLeakPhantomRef.isEnqueued())
            {
                break;
            }
        }
        assertTrue(possibleLeakPhantomRef.isEnqueued());
    }
```

Thanks in advance,
",https://github.com/AsyncHttpClient/async-http-client/issues/1067,1.0,1.0,1.0,54
423,"WebSocketUtil.base64(..) leaks resources
org.vertx.java.tests.core.http.GroovyHttpTest > testPUTChunked STANDARD_OUT
    17:43:22.682 WARN  [vert.x-eventloop-thread-1][io.netty.util.ResourceLeakDetector] LEAK: ByteBuf was GC'd before being released correctly.
    io.netty.util.ResourceLeakException: io.netty.buffer.UnpooledUnsafeDirectByteBuf@46f8fbdb
        at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:158)
        at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
        at io.netty.buffer.UnpooledUnsafeDirectByteBuf.<init>(UnpooledUnsafeDirectByteBuf.java:72)
        at io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:49)
        at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:130)
        at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:121)
        at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:58)
        at io.netty.handler.codec.base64.Base64.encode(Base64.java:115)
        at io.netty.handler.codec.base64.Base64.encode(Base64.java:86)
        at io.netty.handler.codec.base64.Base64.encode(Base64.java:73)
        at io.netty.handler.codec.base64.Base64.encode(Base64.java:69)
        at io.netty.handler.codec.http.websocketx.WebSocketUtil.base64(WebSocketUtil.java:74)
        at io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker13.newHandshakeRequest(WebSocketClientHandshaker13.java:106)
        at io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker.handshake(WebSocketClientHandshaker.java:149)
        at io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker.handshake(WebSocketClientHandshaker.java:137)
        at org.vertx.java.core.http.impl.ClientConnection.toWebSocket(ClientConnection.java:115)
        at org.vertx.java.core.http.impl.DefaultHttpClient$3.handle(DefaultHttpClient.java:153)
        at org.vertx.java.core.http.impl.DefaultHttpClient$3.handle(DefaultHttpClient.java:150)
        at org.vertx.java.core.http.impl.DefaultHttpClient.createConn(DefaultHttpClient.java:540)
        at org.vertx.java.core.http.impl.DefaultHttpClient.access$600(DefaultHttpClient.java:47)
        at org.vertx.java.core.http.impl.DefaultHttpClient$6.run(DefaultHttpClient.java:526)
        at org.vertx.java.core.impl.DefaultContext$3.run(DefaultContext.java:171)
        at org.vertx.java.core.impl.DefaultContext.execute(DefaultContext.java:129)
        at org.vertx.java.core.http.impl.DefaultHttpClient.connected(DefaultHttpClient.java:524)
        at org.vertx.java.core.http.impl.DefaultHttpClient.access$400(DefaultHttpClient.java:47)
        at org.vertx.java.core.http.impl.DefaultHttpClient$5.operationComplete(DefaultHttpClient.java:508)
        at org.vertx.java.core.http.impl.DefaultHttpClient$5.operationComplete(DefaultHttpClient.java:487)
        at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:612)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:577)
        at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:539)
        at io.netty.util.concurrent.DefaultPromise.setSuccess(DefaultPromise.java:380)
        at io.netty.channel.DefaultChannelPromise.setSuccess(DefaultChannelPromise.java:76)
        at io.netty.channel.DefaultChannelPromise.setSuccess(DefaultChannelPromise.java:71)
        at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:232)
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:513)
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:465)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:359)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
        at java.lang.Thread.run(Thread.java:722)
",https://github.com/netty/netty/issues/1579,1.0,1.0,1.0,34
287,"Possible memory leak due to usage of ThreadLocals
I am using HikariCP 2.0.1 with Tomcat 8.0.12. The latter keeps complaining about non-cleared ConcurrentBag threadlocal:

27-Sep-2014 00:14:49.001 SEVERE [localhost-startStop-2] org.apache.catalina.loader.WebappClassLoader.checkThreadLocalMapForLeaks The web application [/medex] created a ThreadLocal with key of type [java.lang.ThreadLocal](value [java.lang.ThreadLocal@4437ca25]) and a value of type [com.zaxxer.hikari.util.FastList](value [com.zaxxer.hikari.util.FastList@62b24a7b]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.

ConcurrentBag uses FastList threadlocal but never removes it. Consequently, this thread cannot be processed by garbage collector.

The easiest and most obvious fix is to provide some shutdown hook for ConcurrentBag allowing to remove it's threadlocal and then use it in pool shutdown routine. As ConcurrentBag will get ""corrupted"" after shutdown call, it makes sense to track it's state in some property and throw IllegalStateException on subsequent attempts to use this concurrent bag (if necessary).

Best regards, Arthur
",https://github.com/brettwooldridge/HikariCP/issues/148,1.0,1.0,1.0,37
425,"When the number of pending unencrypted bytes is high, SslHandler tries to allocate a huge outNet buffer.
### Expected behavior

When a user attempts to write a large buffer (e.g. 1GB) via SslHandler, SslHandler should not attempt to allocate an outNet buffer that's as large as the buffer given by the user, because

- We may not be able to flush fast enough to deallocate it soon.
- A user may get an OOME when under backpressure due to double memory allocation.
- It's inefficient to allocate a direct buffer that's bigger than 16MiB (pooled allocator's chunk size)

### Actual behavior

When a user attempts to write a large buffer, SslHandler should not allocate a huge buffer upfront but only allocate up to certain threshold. e.g. Always keep the number of pending outNet bytes low even if `SslHandler.pendingUnencryptedWrites.bytes` is high.

### Steps to reproduce

- Give JVM relatively small amount of heap and direct memory (e.g. 128m)
- On an SSL connection, attempt to send a buffer that's slightly larger than half of the available direct memory. 
- SslHandler will attempt to allocate a buffer that's as large as the buffer being sent and end up with an OOME.

### Minimal yet complete reproducer code (or URL to code)

I reproduced the problem by running `./gradlew core:check` for [Armeria](https://github.com/line/armeria), but it's not a minimal reproducer obviously. You get the idea though, right? ;-)

### Netty version

4.1.9.Final. No problem with 4.1.8.Final.

### JVM version (e.g. `java -version`)

```
java version ""1.8.0_112""
Java(TM) SE Runtime Environment (build 1.8.0_112-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)
```

### OS version (e.g. `uname -a`)

`Linux porori 4.9.0-0.bpo.2-amd64 #1 SMP Debian 4.9.13-1~bpo8+1 (2017-02-27) x86_64 GNU/Linux`",https://github.com/netty/netty/issues/6564,1.0,1.0,1.0,42
171,"Indexed Scripts/Templates: Indexed Scripts used during reduce phase sometimes hang
Indexed scripts might need to get fetched via a GET call which is very cheap since those shards are local since they expand `[0-all]` but sometimes in the case of a node client holding no data we need to do a get call on the first get. Yet this get call seems to be executed on the transport thread and might deadlock since it needs that thread to process the get response. See stacktrace below... The problem here is that some of the actions in `SearchServiceTransportAction` don't use the `search` threadpool but use `SAME` instead which can cause this issue. We should use `SEARCH` instead for the most of the operations except of free context I guess.

```
2> ""elasticsearch[node_s2][local_transport][T#1]"" ID=1421 WAITING on org.elasticsearch.common.util.concurrent.BaseFuture$Sync@2b1fdd72
  2>    at sun.misc.Unsafe.park(Native Method)
  2>    - waiting on org.elasticsearch.common.util.concurrent.BaseFuture$Sync@2b1fdd72
  2>    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
  2>    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
  2>    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
  2>    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
  2>    at org.elasticsearch.common.util.concurrent.BaseFuture$Sync.get(BaseFuture.java:274)
  2>    at org.elasticsearch.common.util.concurrent.BaseFuture.get(BaseFuture.java:113)
  2>    at org.elasticsearch.action.support.AdapterActionFuture.actionGet(AdapterActionFuture.java:45)
  2>    at org.elasticsearch.script.ScriptService.getScriptFromIndex(ScriptService.java:377)
  2>    at org.elasticsearch.script.ScriptService.compile(ScriptService.java:295)
  2>    at org.elasticsearch.script.ScriptService.executable(ScriptService.java:457)
  2>    at org.elasticsearch.search.aggregations.metrics.scripted.InternalScriptedMetric.reduce(InternalScriptedMetric.java:99)
  2>    at org.elasticsearch.search.aggregations.InternalAggregations.reduce(InternalAggregations.java:140)
  2>    at org.elasticsearch.search.controller.SearchPhaseController.merge(SearchPhaseController.java:374)
  2>    at org.elasticsearch.action.search.type.TransportSearchDfsQueryThenFetchAction$AsyncAction.innerFinishHim(TransportSearchDfsQueryThenFetchAction.java:209)
  2>    at org.elasticsearch.action.search.type.TransportSearchDfsQueryThenFetchAction$AsyncAction.finishHim(TransportSearchDfsQueryThenFetchAction.java:196)
  2>    at org.elasticsearch.action.search.type.TransportSearchDfsQueryThenFetchAction$AsyncAction$2.onResult(TransportSearchDfsQueryThenFetchAction.java:172)
  2>    at org.elasticsearch.action.search.type.TransportSearchDfsQueryThenFetchAction$AsyncAction$2.onResult(TransportSearchDfsQueryThenFetchAction.java:166)
  2>    at org.elasticsearch.search.action.SearchServiceTransportAction$18.handleResponse(SearchServiceTransportAction.java:440)
  2>    at org.elasticsearch.search.action.SearchServiceTransportAction$18.handleResponse(SearchServiceTransportAction.java:431)
  2>    at org.elasticsearch.transport.local.LocalTransport$3.run(LocalTransport.java:322)
  2>    at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:299)
  2>    at org.elasticsearch.transport.local.LocalTransport.handleParsedResponse(LocalTransport.java:317)
  2>    at org.elasticsearch.test.transport.AssertingLocalTransport.handleParsedResponse(AssertingLocalTransport.java:59)
  2>    at org.elasticsearch.transport.local.LocalTransport.handleResponse(LocalTransport.java:313)
  2>    at org.elasticsearch.transport.local.LocalTransport.messageReceived(LocalTransport.java:238)
  2>    at org.elasticsearch.transport.local.LocalTransportChannel$1.run(LocalTransportChannel.java:78)
  2>    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
  2>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
  2>    at java.lang.Thread.run(Thread.java:745)
  2>    Locked synchronizers:
  2>    - java.util.concurrent.ThreadPoolExecutor$Worker@2339bcc9
  2> 
```
",https://github.com/elastic/elasticsearch/issues/7623,1.0,0.0,0.0,41
234,"Minor typos PreAuthenticatedAuthenticationProvider
### Summary
Backport of #4460",https://github.com/spring-projects/spring-security/issues/4769,1.0,2.0,2.0,43
273,"OutOfMemoryError in test suite when upgrading from JUnit 5.2 to 5.3
## Overview

I work on a large project which runs Junit 5 under Gradle (currently version 4.8).  One of our test suites which previously ran fine with a 8 GB max heap size now requires an ~11 GB heap to run without OutOfMemoryError (~12 GB to run without OutOfMemoryError AND without GC overhead slowing things down significantly).

Looking at the release notes, I see nothing that should cause such a significant increase in memory usage from Junit 5 itself, so I was surprised to see this new problem while upgrading versions.

I only found one other open issue mentioning OutOfMemoryError and it involves dynamic tests, which my suite isn't using at all.

I suppose it's possible that some small behavior change in Junit 5.3 sensitizes an issue with my test suite that increases memory consumption, but I can't think of what that might be. 

Are there any changes in Junit 5.3 that are known to increase memory consumption, and thus increase risk of OutOfMemoryError while running tests?

My apologies if this issue seems more like a question and not a real bug report... but I figured it was better to raise the issue quickly after Junit 5.3 release just in case others are going to start hitting the same problem soon.

Unfortunately, I can't share my unit tests from this project.  However, I am going to try to pare down the test suite to see if I can narrow down where the memory increase is happening.  I may or may not be able to come back here later and provide more specific information, after doing that work.

## Deliverables

**Team Decision**:

- [x] Implement the _quick fix_ mentioned by @sbrannen.
- [x] Investigate other possibilities for freeing up unnecessary memory consumption in the `HierarchicalTestEngine` and related infrastructure (specifically in `NodeTestTask`).
- [x] Backport fix and release notes to a new `5.3.1` branch.",https://github.com/junit-team/junit5/issues/1578,1.0,1.0,1.0,51
235,"Misleading code example in reference documentation
In the Spring official docs, [here](https://docs.spring.io/spring-batch/docs/current-SNAPSHOT/reference/html/spring-batch-integration.html#spring-batch-integration-configuration), in the Java configuration code under **Spring Batch Integration Configuration**, there is a typo that is misleading. The `handle()` should be `transform()` in the `integrationFlow` method. 

Artem Bilan asked me to raise this issue when I asked him about it on a [question](https://stackoverflow.com/questions/61100608/why-do-i-get-the-exception-found-ambiguous-parameter-type-spring-batch-integr) in StackOverflow.",https://github.com/spring-projects/spring-batch/issues/3692,1.0,2.0,2.0,41
438,"[Website] Links to generated client docs are broken
The links to the generated client docs on the website return `not found` for many of them. I have tried:

* Java
* Python
* C++

They all reference 2.5.1-SNAPSHOT in the URL, but that doesn't seem to exist. 

There is an example on this page:

[https://pulsar.apache.org/docs/en/client-libraries-java/](https://pulsar.apache.org/docs/en/client-libraries-java/
)
The links in the first table, column Package both return:

```
Not Found
The requested URL was not found on this server.
```

The old versions (2.5.0-SNAPSHOT) are still there if I manually update the URL in my browwer, but it seems the latest 2.5.1 ones are missing.

",https://github.com/apache/pulsar/issues/6900,1.0,2.0,2.0,42
75,"Connection leaks if WebSocket handshake fails
This is a recent regression bisected to dd70407455f09f3eda7288f0bb9610f8943af03e.

It may be the cause for the recent increase in test flakiness.

To reproduce, run this modified test:
```
  @Test public void missingConnectionHeader() throws IOException {
    webServer.enqueue(new MockResponse()
        .setResponseCode(101)
        .setHeader(""Upgrade"", ""websocket"")
        .setHeader(""Sec-WebSocket-Accept"", ""ujmZX4KXZqjwy6vi1aQFH5p4Ygk=""));
    newWebSocket();

    clientListener.assertFailure(101, null, ProtocolException.class,
        ""Expected 'Connection' header value 'Upgrade' but was 'null'"");

    client.connectionPool().evictAll();
    assertEquals(0, client.connectionPool().connectionCount());
  }
```

",https://github.com/square/okhttp/issues/4658,1.0,1.0,1.0,45
285,"Possibility of a memory leak due to a combination of `RealmChangeListener` and `automaticUpdate`
Reported by @zaki50 

`RealmChangeListener` is added to `Realm` when `automaticUpdate` is true. Then the listener instance was not released until the `Realm` instance is released because the `RealmChangeListener` is never deleted.

Since a listener instance is an anonymous inner class of `RealmBaseAdapter`, it holds a reference to the `RealmBaseAdapter` as an enclosing instance. `RealmBaseAdapter` usually holds a reference to the `Activity` that uses it as `Context`. So these instances will not be released until the `Realm` instance is released.

If you use `Realm` in only one Activity, there is no problem because `Realm#close()` is called when the `Activity`  is destroyed. (Strictly speaking, adapters may be accumulated if re-create a `RealmBaseAdapter` while the Activity is alive.)

On the other hand, if you use two activities, there are main activity and another activity that has `ListView`, each activity uses `Realm`, the `Realm` instance is held in cache until `onDestroy` of main activity is called. For example if you transition between the two Activities as follows, Main -> List-> back -> List -> back -> List... I think the `RealmChangeListener` may be accumulated in the `Realm`.

What do you think? @cmelchior @emanuelez 
",https://github.com/realm/realm-java/issues/1109,1.0,1.0,1.0,41
429,"Wrong Dependency in Spring Boot Tutorial
I just noticed that the 'spring-boot-starter-redis' dependency in the spring boot tutorial (https://docs.spring.io/spring-session/docs/current/reference/html5/guides/boot.html) is not longer valid and should be 'spring-boot-starter-data-redis' instead.",https://github.com/spring-projects/spring-session/issues/952,1.0,2.0,2.0,43
436,"[ForkJoinPool] Thread Local Leak detected
The Atmosphere Framework bundles the [ForkJoinPool](https://github.com/netty/netty/blob/master/common/src/main/java/io/netty/util/internal/chmv8/ForkJoinPool.java) implementation of Netty. It seems there is a Thread Local leak as reported [here](https://github.com/Atmosphere/atmosphere/issues/2048)

``` java
SEVERE: The web application [/atmosphere-chat] created a ThreadLocal with key of type [java.lang.ThreadLocal] (value [java.lang.ThreadLocal@41a80e5a]) and a value of type [org.atmosphere.util.chmv8.ForkJoinPool.Submitter]
 (value [org.atmosphere.util.chmv8.ForkJoinPool$Submitter@450ae3fb]) but failed to remove it when the web application was stopped. This is very likely to create a memory leak.
```

When using the JDK7/8 implementation the leak doesn't occurs (no error message) so I suspect the current implementation leaks.
",https://github.com/netty/netty/issues/4211,1.0,1.0,1.0,45
283,"Pool leaks connections open if customization/initSql fails
There seems to be slight a possibility to connection leak in the pool between acquiring a connection and adding it to the pool. Connection state reset has similar problem as well.

Steps to fix the issue (HikariPool.addConnection):
1. Obtaining of a datasource connection should be closed (try/catch) in case of a failure prior it has been added to the pool
2. initSql block should be followed by resetConnectionState in any case (try/finally)
",https://github.com/brettwooldridge/HikariCP/issues/44,1.0,1.0,1.0,53
204,"Link to Port Index Broken In Reference Documentation
The links to Port Index at: https://www.eclipse.org/elk/reference/options.html both point to https://www.eclipse.org/elk/reference/options/org-eclipse-elk-port-",https://github.com/eclipse/elk/issues/268,1.0,2.0,2.0,55
132,"Fix Typo in Reference Docs
### Summary

Backport of #4767",https://github.com/spring-projects/spring-security/issues/4976,1.0,2.0,2.0,49
203,"Leak in OpenSslContext
[OpenSslContext](https://github.com/netty/netty/blob/4.1/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java) (I mean OpenSslClientContext or OpenSslServerContext exactly) object hold some resources (like custom verification callback to verify ssl certificate) which need to be released when this OpenSslContext object is GC. This is done by JVM calling [`finalize`](https://github.com/netty/netty/blob/4.1/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java#L352) in OpenSslContext.

But I found that OpenSslContext will never be GC so all the resources possessed by it will never be released. Take [OpenSslClientContext](https://github.com/netty/netty/blob/4.1/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java) as example but the same bug exists in [OpenSslServerContext](https://github.com/netty/netty/blob/4.1/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java) too. In the constructor of OpenSslClientContext, there's [an anonymous class object](https://github.com/netty/netty/blob/4.1/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java#L253) which is used as a custom verification callback to verify certificate and is set into [SSLContext](https://github.com/netty/netty-tcnative/blob/1.1.33/openssl-dynamic/src/main/java/org/apache/tomcat/jni/SSLContext.java) by calling [SSLContext.setCertVerifyCallback](https://github.com/netty/netty-tcnative/blob/1.1.33/openssl-dynamic/src/main/java/org/apache/tomcat/jni/SSLContext.java#L437). This SSLContext.setCertVerifyCallback is a native function in which [a global reference](https://github.com/netty/netty-tcnative/blob/1.1.33/openssl-dynamic/src/main/c/sslcontext.c#L1619) is created and ref to the custom verification callback passed to SSLContext.setCertVerifyCallback. 

So the custom verification callback used to verify certificate will be released only when OpenSslClientContext object is GC. And the OpenSslClientContext object will be GC only when the custom verification callback is removed from JNI global reference.
",https://github.com/netty/netty/issues/5372,1.0,1.0,1.0,45
74,"Connection leak if SSL connection got reconnected
",https://github.com/redisson/redisson/issues/2845,1.0,1.0,1.0,40
441,"[core] Deadlock
Hi @skylot,

I've noticed that a lot of apps are not decompiled completely. I caught one of them with a deadlock 

jadx-cli args
```
--no-replace-consts --show-bad-code --threads-count 8 --no-inline-anonymous --no-imports --deobf --deobf-min 2 --deobf-rewrite-cfg
```

Output of ``` jstack ```
```
Full thread dump Java HotSpot(TM) 64-Bit Server VM (12.0.2+10 mixed mode, sharing):

Threads class SMR info:
_java_thread_list=0x00007ffec3f45cc0, length=21, elements={
0x00007ffec200b000, 0x00007ffec60b1800, 0x00007ffec2004000, 0x00007ffec5834000,
0x00007ffec5833000, 0x00007ffec5837000, 0x00007ffec5008800, 0x00007ffec5860000,
0x00007ffec508f800, 0x00007ffec2923000, 0x00007ffec662e000, 0x00007ffec7755000,
0x00007ffec30af000, 0x00007ffec30b2000, 0x00007ffec4115000, 0x00007ffec32f3800,
0x00007ffec4116000, 0x00007ffec32fe800, 0x00007ffec5a9a000, 0x00007ffec742f000,
0x00007ffec8341800
}

""main"" #1 prio=5 os_prio=31 cpu=6028.67ms elapsed=150.42s tid=0x00007ffec200b000 nid=0x2203 waiting on condition  [0x000070000eb68000]
   java.lang.Thread.State: TIMED_WAITING (parking)
	at jdk.internal.misc.Unsafe.park(java.base@12.0.2/Native Method)
	- parking to wait for  <0x000000046b2754d0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.parkNanos(java.base@12.0.2/LockSupport.java:235)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(java.base@12.0.2/AbstractQueuedSynchronizer.java:2123)
	at java.util.concurrent.ThreadPoolExecutor.awaitTermination(java.base@12.0.2/ThreadPoolExecutor.java:1454)
	at jadx.api.JadxDecompiler.save(JadxDecompiler.java:143)
	at jadx.api.JadxDecompiler.save(JadxDecompiler.java:128)
	at jadx.cli.JadxCLI.processAndSave(JadxCLI.java:39)
	at jadx.cli.JadxCLI.main(JadxCLI.java:19)

   Locked ownable synchronizers:
	- None

""Reference Handler"" #2 daemon prio=10 os_prio=31 cpu=1.32ms elapsed=150.40s tid=0x00007ffec60b1800 nid=0x4403 waiting on condition  [0x000070001007d000]
   java.lang.Thread.State: RUNNABLE
	at java.lang.ref.Reference.waitForReferencePendingList(java.base@12.0.2/Native Method)
	at java.lang.ref.Reference.processPendingReferences(java.base@12.0.2/Reference.java:241)
	at java.lang.ref.Reference$ReferenceHandler.run(java.base@12.0.2/Reference.java:213)

   Locked ownable synchronizers:
	- None

""Finalizer"" #3 daemon prio=8 os_prio=31 cpu=0.20ms elapsed=150.40s tid=0x00007ffec2004000 nid=0x3703 in Object.wait()  [0x0000700010f80000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(java.base@12.0.2/Native Method)
	- waiting on <0x000000044479a3d0> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(java.base@12.0.2/ReferenceQueue.java:155)
	- locked <0x000000044479a3d0> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(java.base@12.0.2/ReferenceQueue.java:176)
	at java.lang.ref.Finalizer$FinalizerThread.run(java.base@12.0.2/Finalizer.java:170)

   Locked ownable synchronizers:
	- None

""Signal Dispatcher"" #4 daemon prio=9 os_prio=31 cpu=0.26ms elapsed=150.40s tid=0x00007ffec5834000 nid=0x3d03 runnable  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

""C2 CompilerThread0"" #5 daemon prio=9 os_prio=31 cpu=9832.54ms elapsed=150.40s tid=0x00007ffec5833000 nid=0xa903 waiting on condition  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
   No compile task

   Locked ownable synchronizers:
	- None

""C1 CompilerThread0"" #8 daemon prio=9 os_prio=31 cpu=3159.32ms elapsed=150.40s tid=0x00007ffec5837000 nid=0x5603 waiting on condition  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
   No compile task

   Locked ownable synchronizers:
	- None

""Sweeper thread"" #9 daemon prio=9 os_prio=31 cpu=82.48ms elapsed=150.40s tid=0x00007ffec5008800 nid=0xa603 runnable  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

""Service Thread"" #10 daemon prio=9 os_prio=31 cpu=4.99ms elapsed=150.38s tid=0x00007ffec5860000 nid=0x5903 runnable  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

""Common-Cleaner"" #11 daemon prio=8 os_prio=31 cpu=1.34ms elapsed=150.38s tid=0x00007ffec508f800 nid=0x5c03 in Object.wait()  [0x0000700014e95000]
   java.lang.Thread.State: TIMED_WAITING (on object monitor)
	at java.lang.Object.wait(java.base@12.0.2/Native Method)
	- waiting on <no object reference available>
	at java.lang.ref.ReferenceQueue.remove(java.base@12.0.2/ReferenceQueue.java:155)
	- locked <0x000000044479ad88> (a java.lang.ref.ReferenceQueue$Lock)
	at jdk.internal.ref.CleanerImpl.run(java.base@12.0.2/CleanerImpl.java:148)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)
	at jdk.internal.misc.InnocuousThread.run(java.base@12.0.2/InnocuousThread.java:134)

   Locked ownable synchronizers:
	- None

""pool-1-thread-1"" #12 prio=5 os_prio=31 cpu=2235.01ms elapsed=143.88s tid=0x00007ffec2923000 nid=0x8f03 waiting for monitor entry  [0x0000700016ecb000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423df9f0> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b276298> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-2"" #13 prio=5 os_prio=31 cpu=4026.55ms elapsed=143.88s tid=0x00007ffec662e000 nid=0x8c03 waiting for monitor entry  [0x0000700017dce000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423d76b8> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b2eadd8> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-3"" #14 prio=5 os_prio=31 cpu=2233.49ms elapsed=143.88s tid=0x00007ffec7755000 nid=0x7003 waiting for monitor entry  [0x0000700018cd0000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.dex.nodes.ClassNode.loadAndProcess(ClassNode.java:251)
	at jadx.core.dex.nodes.RootNode.getClassGenerics(RootNode.java:279)
	at jadx.core.utils.TypeUtils.replaceClassGenerics(TypeUtils.java:35)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.invokeListener(TypeUpdate.java:296)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$45/0x00000008011adc40.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:73)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:50)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.applyImmutableType(TypeInferenceVisitor.java:155)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.setImmutableType(TypeInferenceVisitor.java:136)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor$$Lambda$126/0x000000080126b840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.runTypePropagation(TypeInferenceVisitor.java:102)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.visit(TypeInferenceVisitor.java:71)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:30)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:15)
	at jadx.core.dex.visitors.DepthTraversal$$Lambda$90/0x0000000801246840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:15)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$0(DepthTraversal.java:14)
	at jadx.core.dex.visitors.DepthTraversal$$Lambda$89/0x0000000801247440.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:43)
	- locked <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004422eb2f0> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b3604f8> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-4"" #15 prio=5 os_prio=31 cpu=2264.72ms elapsed=143.88s tid=0x00007ffec30af000 nid=0x8703 waiting for monitor entry  [0x0000700019bd4000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423f94e8> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b3d5550> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-5"" #16 prio=5 os_prio=31 cpu=2017.32ms elapsed=143.88s tid=0x00007ffec30b2000 nid=0x7203 waiting for monitor entry  [0x000070001aad7000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423a1f28> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b000360> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-6"" #17 prio=5 os_prio=31 cpu=2136.99ms elapsed=143.88s tid=0x00007ffec4115000 nid=0x7303 waiting for monitor entry  [0x000070001b9da000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:60)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x000000044243a208> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b0eac38> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-7"" #18 prio=5 os_prio=31 cpu=2134.24ms elapsed=143.88s tid=0x00007ffec32f3800 nid=0x7403 waiting for monitor entry  [0x000070001c8db000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass.process(ProcessClass.java:27)
	at jadx.core.dex.nodes.ClassNode.loadAndProcess(ClassNode.java:251)
	at jadx.core.dex.nodes.RootNode.getClassGenerics(RootNode.java:279)
	at jadx.core.utils.TypeUtils.replaceClassGenerics(TypeUtils.java:35)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.invokeListener(TypeUpdate.java:296)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$45/0x00000008011adc40.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.moveListener(TypeUpdate.java:324)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$36/0x00000008011af840.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.moveListener(TypeUpdate.java:324)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$36/0x00000008011af840.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:142)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.moveListener(TypeUpdate.java:324)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$36/0x00000008011af840.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:73)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:50)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.applyImmutableType(TypeInferenceVisitor.java:155)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.setImmutableType(TypeInferenceVisitor.java:136)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor$$Lambda$126/0x000000080126b840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.runTypePropagation(TypeInferenceVisitor.java:102)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.visit(TypeInferenceVisitor.java:71)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:30)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:15)
	at jadx.core.dex.visitors.DepthTraversal$$Lambda$90/0x0000000801246840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:15)
	at jadx.core.ProcessClass.process(ProcessClass.java:43)
	- locked <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:60)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423a5b08> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b075828> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""pool-1-thread-8"" #19 prio=5 os_prio=31 cpu=2154.06ms elapsed=143.87s tid=0x00007ffec4116000 nid=0x8003 waiting for monitor entry  [0x000070001d7e0000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x0000000446a769b8> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- <0x000000046b2eb100> (a java.util.concurrent.ThreadPoolExecutor$Worker)

""Java2D Disposer"" #21 daemon prio=10 os_prio=31 cpu=1.86ms elapsed=141.24s tid=0x00007ffec32fe800 nid=0x7907 in Object.wait()  [0x000070001e6e3000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(java.base@12.0.2/Native Method)
	- waiting on <0x000000046b3d56f8> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(java.base@12.0.2/ReferenceQueue.java:155)
	- locked <0x000000046b3d56f8> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(java.base@12.0.2/ReferenceQueue.java:176)
	at sun.java2d.Disposer.run(java.desktop@12.0.2/Disposer.java:144)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- None

""AppKit Thread"" #22 daemon prio=5 os_prio=31 cpu=264.56ms elapsed=141.21s tid=0x00007ffec5a9a000 nid=0x307 runnable  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

""Java2D Queue Flusher"" #24 daemon prio=10 os_prio=31 cpu=83.59ms elapsed=140.95s tid=0x00007ffec742f000 nid=0xf507 in Object.wait()  [0x00007000207fb000]
   java.lang.Thread.State: TIMED_WAITING (on object monitor)
	at java.lang.Object.wait(java.base@12.0.2/Native Method)
	- waiting on <no object reference available>
	at sun.java2d.opengl.OGLRenderQueue$QueueFlusher.run(java.desktop@12.0.2/OGLRenderQueue.java:205)
	- locked <0x000000046b075b48> (a sun.java2d.opengl.OGLRenderQueue$QueueFlusher)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

   Locked ownable synchronizers:
	- None

""Attach Listener"" #54 daemon prio=9 os_prio=31 cpu=0.61ms elapsed=0.57s tid=0x00007ffec8341800 nid=0xc063 waiting on condition  [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
	- None

""VM Thread"" os_prio=31 cpu=583.42ms elapsed=150.41s tid=0x00007ffec5832000 nid=0x4503 runnable  

""GC Thread#0"" os_prio=31 cpu=357.17ms elapsed=150.42s tid=0x00007ffec581e800 nid=0x4f03 runnable  

""GC Thread#1"" os_prio=31 cpu=372.99ms elapsed=149.43s tid=0x00007ffec60a1800 nid=0x5f07 runnable  

""GC Thread#2"" os_prio=31 cpu=364.40ms elapsed=149.43s tid=0x00007ffec6158000 nid=0x5e07 runnable  

""GC Thread#3"" os_prio=31 cpu=363.83ms elapsed=149.43s tid=0x00007ffec6159000 nid=0x6207 runnable  

""GC Thread#4"" os_prio=31 cpu=378.84ms elapsed=149.43s tid=0x00007ffec2018000 nid=0xa003 runnable  

""GC Thread#5"" os_prio=31 cpu=374.66ms elapsed=149.43s tid=0x00007ffec6152000 nid=0x6403 runnable  

""GC Thread#6"" os_prio=31 cpu=245.64ms elapsed=148.57s tid=0x00007ffec290d000 nid=0x6e03 runnable  

""GC Thread#7"" os_prio=31 cpu=247.52ms elapsed=148.57s tid=0x00007ffec304e000 nid=0x9103 runnable  

""G1 Main Marker"" os_prio=31 cpu=0.56ms elapsed=150.42s tid=0x00007ffec500a000 nid=0x4d03 runnable  

""G1 Conc#0"" os_prio=31 cpu=230.08ms elapsed=150.42s tid=0x00007ffec581f800 nid=0x4a03 runnable  

""G1 Conc#1"" os_prio=31 cpu=235.44ms elapsed=148.63s tid=0x00007ffec49d7800 nid=0x6d03 runnable  

""G1 Refine#0"" os_prio=31 cpu=285.65ms elapsed=150.41s tid=0x00007ffec60a0000 nid=0x3003 runnable  

""G1 Refine#1"" os_prio=31 cpu=116.28ms elapsed=148.85s tid=0x00007ffec3099000 nid=0x9b03 runnable  

""G1 Refine#2"" os_prio=31 cpu=81.27ms elapsed=148.85s tid=0x00007ffec5861800 nid=0x9a03 runnable  

""G1 Refine#3"" os_prio=31 cpu=56.36ms elapsed=148.85s tid=0x00007ffec309a000 nid=0x9803 runnable  

""G1 Refine#4"" os_prio=31 cpu=50.29ms elapsed=148.85s tid=0x00007ffec291f000 nid=0x9603 runnable  

""G1 Refine#5"" os_prio=31 cpu=27.60ms elapsed=148.85s tid=0x00007ffec40c3800 nid=0x6a03 runnable  

""G1 Refine#6"" os_prio=31 cpu=26.09ms elapsed=148.85s tid=0x00007ffec309a800 nid=0x9403 runnable  

""G1 Refine#7"" os_prio=31 cpu=27.13ms elapsed=148.84s tid=0x00007ffec309b800 nid=0x6b03 runnable  

""G1 Young RemSet Sampling"" os_prio=31 cpu=129.26ms elapsed=150.41s tid=0x00007ffec60a1000 nid=0x4803 runnable  
""VM Periodic Task Thread"" os_prio=31 cpu=118.62ms elapsed=150.38s tid=0x00007ffec508e800 nid=0xa303 waiting on condition  

JNI global refs: 77, weak refs: 2


Found one Java-level deadlock:
=============================
""pool-1-thread-1"":
  waiting to lock monitor 0x000000014600b200 (object 0x0000000444a58f28, a jadx.core.dex.info.ClassInfo),
  which is held by ""pool-1-thread-7""
""pool-1-thread-7"":
  waiting to lock monitor 0x0000000145e9ee00 (object 0x0000000444a53c20, a jadx.core.dex.info.ClassInfo),
  which is held by ""pool-1-thread-3""
""pool-1-thread-3"":
  waiting to lock monitor 0x000000014600b200 (object 0x0000000444a58f28, a jadx.core.dex.info.ClassInfo),
  which is held by ""pool-1-thread-7""

Java stack information for the threads listed above:
===================================================
""pool-1-thread-1"":
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423df9f0> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)
""pool-1-thread-7"":
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass.process(ProcessClass.java:27)
	at jadx.core.dex.nodes.ClassNode.loadAndProcess(ClassNode.java:251)
	at jadx.core.dex.nodes.RootNode.getClassGenerics(RootNode.java:279)
	at jadx.core.utils.TypeUtils.replaceClassGenerics(TypeUtils.java:35)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.invokeListener(TypeUpdate.java:296)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$45/0x00000008011adc40.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.moveListener(TypeUpdate.java:324)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$36/0x00000008011af840.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.moveListener(TypeUpdate.java:324)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$36/0x00000008011af840.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:142)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.moveListener(TypeUpdate.java:324)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$36/0x00000008011af840.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:73)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:50)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.applyImmutableType(TypeInferenceVisitor.java:155)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.setImmutableType(TypeInferenceVisitor.java:136)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor$$Lambda$126/0x000000080126b840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.runTypePropagation(TypeInferenceVisitor.java:102)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.visit(TypeInferenceVisitor.java:71)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:30)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:15)
	at jadx.core.dex.visitors.DepthTraversal$$Lambda$90/0x0000000801246840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:15)
	at jadx.core.ProcessClass.process(ProcessClass.java:43)
	- locked <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:60)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004423a5b08> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)
""pool-1-thread-3"":
	at jadx.core.ProcessClass.process(ProcessClass.java:35)
	- waiting to lock <0x0000000444a58f28> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.dex.nodes.ClassNode.loadAndProcess(ClassNode.java:251)
	at jadx.core.dex.nodes.RootNode.getClassGenerics(RootNode.java:279)
	at jadx.core.utils.TypeUtils.replaceClassGenerics(TypeUtils.java:35)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.invokeListener(TypeUpdate.java:296)
	at jadx.core.dex.visitors.typeinference.TypeUpdate$$Lambda$45/0x00000008011adc40.update(Unknown Source)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.runListeners(TypeUpdate.java:190)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdate(TypeUpdate.java:171)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.requestUpdateForSsaVar(TypeUpdate.java:148)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeForSsaVar(TypeUpdate.java:136)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.updateTypeChecked(TypeUpdate.java:116)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:73)
	at jadx.core.dex.visitors.typeinference.TypeUpdate.apply(TypeUpdate.java:50)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.applyImmutableType(TypeInferenceVisitor.java:155)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.setImmutableType(TypeInferenceVisitor.java:136)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor$$Lambda$126/0x000000080126b840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.runTypePropagation(TypeInferenceVisitor.java:102)
	at jadx.core.dex.visitors.typeinference.TypeInferenceVisitor.visit(TypeInferenceVisitor.java:71)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:30)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$1(DepthTraversal.java:15)
	at jadx.core.dex.visitors.DepthTraversal$$Lambda$90/0x0000000801246840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:15)
	at jadx.core.dex.visitors.DepthTraversal.lambda$visit$0(DepthTraversal.java:14)
	at jadx.core.dex.visitors.DepthTraversal$$Lambda$89/0x0000000801247440.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.dex.visitors.DepthTraversal.visit(DepthTraversal.java:14)
	at jadx.core.ProcessClass.process(ProcessClass.java:43)
	- locked <0x0000000444a53c20> (a jadx.core.dex.info.ClassInfo)
	at jadx.core.ProcessClass$$Lambda$153/0x000000080127a840.accept(Unknown Source)
	at java.util.ArrayList.forEach(java.base@12.0.2/ArrayList.java:1540)
	at jadx.core.ProcessClass.generateCode(ProcessClass.java:61)
	at jadx.core.dex.nodes.ClassNode.decompile(ClassNode.java:262)
	- locked <0x00000004422eb2f0> (a jadx.core.dex.nodes.ClassNode)
	at jadx.api.JavaClass.getCodeInfo(JavaClass.java:53)
	at jadx.api.JadxDecompiler.lambda$appendSourcesSave$0(JadxDecompiler.java:201)
	at jadx.api.JadxDecompiler$$Lambda$74/0x00000008011f0040.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@12.0.2/ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@12.0.2/ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(java.base@12.0.2/Thread.java:835)

Found 1 deadlock.
```

APK: https://drive.google.com/file/d/18wPwqqSeeppz5LDybFX3CLvAZJ3sB7JJ/view?usp=sharing",https://github.com/skylot/jadx/issues/743,1.0,0.0,0.0,38
65,"ConcurrentModificationException in THashIterator
I've just caught the following exception:
```
null
java.util.ConcurrentModificationException
	at gnu.trove.THashIterator.nextIndex(THashIterator.java:83)
	at gnu.trove.TIterator.moveToNextIndex(TIterator.java:88)
	at gnu.trove.THashIterator.next(THashIterator.java:67)
	at com.intellij.util.containers.RefHashMap$EntrySet$1.hasNext(RefHashMap.java:308)
	at com.intellij.util.containers.RefHashMap$EntrySet.isEmpty(RefHashMap.java:340)
	at com.intellij.util.containers.RefHashMap.isEmpty(RefHashMap.java:205)
	at com.intellij.util.containers.WeakHashMap.isEmpty(WeakHashMap.java:36)
	at mobi.hsz.idea.gitignore.IgnoreManager.isFileTracked(IgnoreManager.java:369)
	at mobi.hsz.idea.gitignore.projectView.IgnoreViewNodeDecorator.decorate(IgnoreViewNodeDecorator.java:89)
	at com.intellij.ide.projectView.impl.nodes.AbstractPsiBasedNode.a(AbstractPsiBasedNode.java:169)
	at com.intellij.openapi.application.impl.ApplicationImpl.runReadAction(ApplicationImpl.java:934)
	at com.intellij.ide.projectView.impl.nodes.AbstractPsiBasedNode.update(AbstractPsiBasedNode.java:139)
	at com.intellij.ide.util.treeView.PresentableNodeDescriptor.getUpdatedPresentation(PresentableNodeDescriptor.java:88)
	at com.intellij.ide.util.treeView.PresentableNodeDescriptor.update(PresentableNodeDescriptor.java:41)
	at com.intellij.ide.util.treeView.AbstractTreeBuilder.updateNodeDescriptor(AbstractTreeBuilder.java:577)
	at com.intellij.ide.util.treeView.AbstractTreeUi$22.perform(AbstractTreeUi.java:935)
	at com.intellij.ide.util.treeView.TreeRunnable.run(TreeRunnable.java:36)
	at com.intellij.ide.util.treeView.AbstractTreeUi.execute(AbstractTreeUi.java:1856)
	at com.intellij.ide.util.treeView.AbstractTreeUi.update(AbstractTreeUi.java:931)
	at com.intellij.ide.util.treeView.AbstractTreeUi.update(AbstractTreeUi.java:883)
	at com.intellij.ide.util.treeView.AbstractTreeUi.access$1600(AbstractTreeUi.java:64)
	at com.intellij.ide.util.treeView.AbstractTreeUi$24$1.run(AbstractTreeUi.java:1092)
	at com.intellij.ide.util.treeView.AbstractTreeUi.execute(AbstractTreeUi.java:1835)
	at com.intellij.ide.util.treeView.AbstractTreeUi.access$5200(AbstractTreeUi.java:64)
	at com.intellij.ide.util.treeView.AbstractTreeUi$33.perform(AbstractTreeUi.java:1801)
	at com.intellij.ide.util.treeView.TreeRunnable.run(TreeRunnable.java:36)
	at com.intellij.ide.util.treeView.AbstractTreeUi.executeYieldingRequest(AbstractTreeUi.java:2090)
	at com.intellij.ide.util.treeView.AbstractTreeUi.access$5800(AbstractTreeUi.java:64)
	at com.intellij.ide.util.treeView.AbstractTreeUi$36$1.perform(AbstractTreeUi.java:2002)
	at com.intellij.ide.util.treeView.TreeRunnable.run(TreeRunnable.java:36)
	at com.intellij.ide.util.treeView.AbstractTreeBuilder.runOnYeildingDone(AbstractTreeBuilder.java:433)
	at com.intellij.ide.util.treeView.AbstractTreeUi.runOnYieldingDone(AbstractTreeUi.java:2185)
	at com.intellij.ide.util.treeView.AbstractTreeUi$36.perform(AbstractTreeUi.java:1997)
	at com.intellij.ide.util.treeView.TreeRunnable.run(TreeRunnable.java:36)
	at com.intellij.ide.util.treeView.AbstractTreeBuilder.lambda$new$0(AbstractTreeBuilder.java:51)
	at com.intellij.util.containers.TransferToEDTQueue.processNext(TransferToEDTQueue.java:102)
	at com.intellij.util.containers.TransferToEDTQueue.access$300(TransferToEDTQueue.java:37)
	at com.intellij.util.containers.TransferToEDTQueue$1.run(TransferToEDTQueue.java:57)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:311)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:762)
	at java.awt.EventQueue.access$500(EventQueue.java:98)
	at java.awt.EventQueue$3.run(EventQueue.java:715)
	at java.awt.EventQueue$3.run(EventQueue.java:709)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:732)
	at com.intellij.ide.IdeEventQueue.e(IdeEventQueue.java:821)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:649)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:365)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)
```

IntelliJ IDEA 2017.2.1
Build #IU-172.3544.35, built on July 31, 2017

JRE: 1.8.0_152-release-915-b6 x86_64
JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
Mac OS X 10.12.6",https://github.com/JetBrains/idea-gitignore/issues/413,1.0,0.0,0.0,48
460,"exception in hashedwheelTimer
Exception in thread ""pool-2-thread-1"" java.lang.NullPointerException
        at io.netty.util.HashedWheelTimer$HashedWheelBucket.addTimeout(HashedWheelTimer.java:625)
        at io.netty.util.HashedWheelTimer$Worker.transferTimeoutsToBuckets(HashedWheelTimer.java:411)
        at io.netty.util.HashedWheelTimer$Worker.run(HashedWheelTimer.java:368)
        at java.lang.Thread.run(Thread.java:744)
",https://github.com/netty/netty/issues/2662,1.0,0.0,0.0,34
198,"JavadocType doesn't report unused param tag
TestClass.java

```
package test;

/**
 * TestClass.
 * 
 * @param BAD
 *            This doesn't exist.
 */
public class TestClass {
    public void test() {
    }
}
```

config.xml

```
<?xml version=""1.0""?>
<!DOCTYPE module PUBLIC
          ""-//Puppy Crawl//DTD Check Configuration 1.3//EN""
          ""http://www.puppycrawl.com/dtds/configuration_1_3.dtd"">

<module name=""Checker"">
    <property name=""charset"" value=""ASCII"" />
    <property name=""severity"" value=""error"" />
    <property name=""fileExtensions"" value=""java"" />

    <module name=""TreeWalker"">
        <module name=""JavadocType"">
            <property name=""scope"" value=""public"" />
        </module>
    </module>
</module>
```

output from: `java -jar checkstyle-6.14.1-all.jar -c config.xml TestClass.java`

```
Starting audit...
Audit done.
```

Expected output:

```
Starting audit...
[ERROR] D:\Rickys\Java\EclipseStuff\checkstyle\src\main\java\test\TestClass.java:6:4: Unused @param tag for 'BAD'. [JavadocType]
Audit done.
Checkstyle ends with 1 errors.
```

JavadocType should validate that if a param is defined, that it is used in the class definition so the 2 stay in synch. JavadocMethod will report unused params, so Type should follow suite.

Just as a note, class parameters are used by generic classes. (Ex: ArrayList&lt;T&gt;, T is considered the parameter)
",https://github.com/checkstyle/checkstyle/issues/2811,1.0,3.0,3.0,42
134,"Fix broken link in README.adoc
<!--
For Security Vulnerabilities, please use https://pivotal.io/security#reporting
-->

### Summary
The **Pull Request** link to Github's article in README.adoc is broken. See https://github.com/spring-projects/spring-security#contributing

<!-- 
Please provide a high level summary of the issue you are having
-->

### Actual Behavior
Clicking the **Pull Request** link results in 404.
<!-- 
Please describe step by step the behavior you are observing
-->

### Expected Behavior
Clicking the **Pull Request** link should navigate to the correct Github page https://help.github.com/articles/creating-a-pull-request
<!--
Please describe step by step the behavior you expect
-->

### Configuration
N/A
<!--
Please provide any configuration you have.
-->

### Version
All
<!--
Please describe what version you are using. Does the problem occur in other versions?
-->

### Sample
N/A
<!--
Providing a complete sample (i.e. link to a github repository) will give this issue higher
priority than issues that do not have a complete sample
-->
",https://github.com/spring-projects/spring-security/issues/6521,1.0,2.0,2.0,47
478,"org.redisson.RedissonTopic.removeAllListeners got blocked on CountDownLatch.await
Hi there,

We hit an issue in one of our server using Redission as Redis Client. We do have a single thread executor handling subscribe/unsubscribe for multiple channels. But last week, we found this got blocked on one server . Below is the thread print

""pool-12-thread-1"" #67 prio=5 os_prio=0 tid=0x00007f9f6c9e1000 nid=0x5091 waiting on condition [0x00007f9f6a2f6000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000006cc5406a8> (a java.util.concurrent.CountDownLatch$Sync)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
	at org.redisson.pubsub.AsyncSemaphore.acquireUninterruptibly(AsyncSemaphore.java:49)
	at org.redisson.RedissonTopic.removeAllListeners(RedissonTopic.java:89)

The org.redisson.RedissonTopic.removeAllListeners is unable to respond request, and blocked in the acquireUninterruptibly FOREVER. I tried to dig into logs, there was one exception thrown before this in CommandAsyncService.syncSubscription line 125 ""Subscribe timeout 9500ms"". This is possibly related since this was the only ""Subscribe timeout"" message I saw in last 30 days logs and then this issue happened. But I still don't find prove on this. Looks like this is a rare case since we just hit once. I tried to reproduce locally but with no luck.

I think the removeAllListeners should give an option to let caller pass in a timeout. But this is also not going to resolve the root cause. I am wondering if other people have observed this issue before. Please advise if you have any ideas on this, thanks.




  



",https://github.com/redisson/redisson/issues/1268,1.0,0.0,0.0,40
248,"Native (java) process memory leak
An internal memory leak when using GarbageCollectorMXBean#getLastGcInfo in the JVM. Disable using it...
",https://github.com/elastic/elasticsearch/issues/1118,1.0,1.0,1.0,47
191,"JarResourceManager leaks an InputStream when asked for a Resource for the root of a jar
Due to how Undertow's `URLResource` and the JDK's `JarURLConnection` work, if `JarResourceManager` is asked for an entry for the root of a jar (a path of `""""` or `""/""`), it will open an `InputStream` and never close it. To avoid this, we need to avoid asking the `URLResource` for its content length for such resources.",https://github.com/spring-projects/spring-boot/issues/17121,1.0,1.0,1.0,61
118,"ExoPlayer set up with Rtmp extension leaks memory when closing the activity with playerView
### Issue description
LeakCanary detects a leak when closing activity with PlayerView.

I'm using the ExoPlayer with Rtmp extensions to display the live stream. When the url is invalid (there is no live stream there) the leak occurs. 

This is how the releasePlayer method looks like
```
private fun releasePlayer() {
        player?.release()
        player = null
        playerView.player = null
        mediaSource = null
        trackSelector = null
}
```

![screenshot_20180514-081829](https://user-images.githubusercontent.com/12660801/39981425-d7a85e26-5750-11e8-8459-e509f8e63483.jpg)

### Version of ExoPlayer being used
2.8.0


",https://github.com/google/ExoPlayer/issues/4249,1.0,1.0,1.0,41
494,"webtools update site moved
looks like webtools update site moved from [http://download.eclipse.org/webtools/downloads/drops/R3.8.1/R-3.8.1-20160912100321/repository](http://download.eclipse.org/webtools/downloads/drops/R3.8.1/R-3.8.1-20160912100321/repository)
to 
[http://archive.eclipse.org/webtools/downloads/drops/R3.8/R3.8.1/R-3.8.1-20160912100321/repository/](http://archive.eclipse.org/webtools/downloads/drops/R3.8/R3.8.1/R-3.8.1-20160912100321/repository/)",https://github.com/eclipse/n4js/issues/938,1.0,2.0,2.0,45
136,"Fix concurrency issue in DeadlockThreadRegistry
#### Description

If addDeadlockedThread and getDeadlockedThreadIdSet operation performed concurrently on deadlockedThreadIdSet in DeadlockThreadRegistry class.

Concurrency issue will occur.
```java
public class DeadlockThreadRegistry implements DeadlockThreadLocator {

    private final Set<Long> deadlockedThreadIdSet = new HashSet<Long>();

    boolean addDeadlockedThread(long threadId);

    public Set<Long> getDeadlockedThreadIdSet();
}
```


related issue #2941 

",https://github.com/naver/pinpoint/issues/3712,1.0,0.0,0.0,48
485,"spring-security-bom provides dependency management for itself
### Summary

In 5.0.0.RELEASE, `spring-security-bom` has started providing dependency management for itself.

### Actual Behavior

`spring-security-bom` provides dependency management for an `org.springframework.security:spring-security-bom` jar artifact that does not exist.

### Expected Behavior

`spring-security-bom` does not provide dependency management for a `org.springframework.security:spring-security-bom` jar artifact.

### Configuration

N/A

### Version

5.0.0.RELEASE

### Sample

N/A
",https://github.com/spring-projects/spring-security/issues/4878,1.0,2.0,2.0,44
486,"thread blocked at closeNodeConnections
Hi,

The call to closeNodeConnection waits indefinitely on call to MasterSlaveConnectionManager.closeNodeConnections.

**Section from thread dump:**
```
/service/soap
Transaction type: Web
Transaction name: /service/soap
Duration: 818,433.1 milliseconds
CPU time: 34.0 milliseconds
""qtp1957530885-64062"" #64062
   java.lang.Thread.State: WAITING
        at java.lang.Object.wait(Native Method)
        - waiting on io.netty.util.concurrent.ImmediateEventExecutor$ImmediatePromise@5dd96fe
        at java.lang.Object.wait(Object.java:328)
        at io.netty.util.concurrent.DefaultPromise.awaitUninterruptibly(DefaultPromise.java:254)
        at io.netty.util.concurrent.DefaultPromise.syncUninterruptibly(DefaultPromise.java:340)
        at org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:128)
        at org.redisson.misc.RedissonPromise.syncUninterruptibly(RedissonPromise.java:35)
        at org.redisson.connection.MasterSlaveConnectionManager.closeNodeConnections(MasterSlaveConnectionManager.java:234)
        at org.redisson.cluster.ClusterConnectionManager.shutdown(ClusterConnectionManager.java:780)
        at org.redisson.Redisson.shutdown(Redisson.java:670)
        at com.zimbra.cs.mailbox.redis.RedissonRetryClient.restart(RedissonRetryClient.java:117)
        - locked on com.zimbra.cs.mailbox.redis.RedissonRetryClient@58a8ea4c
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator.reconnect(RedissonRetryDecorator.java:64)
        - locked on com.zimbra.cs.mailbox.redis.RedissonRetryScript@67d62c10
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator.access$000(RedissonRetryDecorator.java:15)
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator$1.run(RedissonRetryDecorator.java:35)
        at com.zimbra.cs.util.RetryUtil$RequestWithRetry.execute(RetryUtil.java:26)
        at com.zimbra.cs.mailbox.redis.RedissonRetryDecorator.runCommand(RedissonRetryDecorator.java:82)
        at com.zimbra.cs.mailbox.redis.RedissonRetryScript.eval(RedissonRetryScript.java:171)
        at com.zimbra.cs.mailbox.redis.RedisBackedLRUItemCache$LRUCacheTrimScript.trimCache(RedisBackedLRUItemCache.java:68)
        at com.zimbra.cs.mailbox.TransactionAwareLRUItemCache$LRUCacheCachedObject.trimCache(TransactionAwareLRUItemCache.java:134)
        at com.zimbra.cs.mailbox.TransactionAwareLRUItemCache.trimCache(TransactionAwareLRUItemCache.java:43)
        at com.zimbra.cs.mailbox.cache.RedisItemCache.trim(RedisItemCache.java:132)
        at com.zimbra.cs.mailbox.Mailbox.trimItemCache(Mailbox.java:9211)
        at com.zimbra.cs.mailbox.Mailbox.commitCache(Mailbox.java:9095)
        at com.zimbra.cs.mailbox.Mailbox.access$1900(Mailbox.java:295)
        at com.zimbra.cs.mailbox.Mailbox$MailboxTransaction.close(Mailbox.java:10168)
        at com.zimbra.cs.mailbox.MailboxIndex.search(MailboxIndex.java:604)
        at com.zimbra.cs.index.DBQueryOperation.dbSearch(DBQueryOperation.java:669)
        at com.zimbra.cs.index.DBQueryOperation.luceneFirstGetNextChunk(DBQueryOperation.java:798)
        at com.zimbra.cs.index.DBQueryOperation.getNextChunk(DBQueryOperation.java:844)
        at com.zimbra.cs.index.DBQueryOperation.peekNext(DBQueryOperation.java:526)
        at com.zimbra.cs.index.QueryOperation.hasNext(QueryOperation.java:169)
        at com.zimbra.cs.index.ItemPreloadingGrouper.bufferHits(ItemPreloadingGrouper.java:54)
        at com.zimbra.cs.index.BufferingResultsGrouper.hasNext(BufferingResultsGrouper.java:68)
        at com.zimbra.cs.index.ConvQueryResults.internalGetNextHit(ConvQueryResults.java:59)
        at com.zimbra.cs.index.ConvQueryResults.bufferNextHit(ConvQueryResults.java:117)
        at com.zimbra.cs.index.ConvQueryResults.peekNext(ConvQueryResults.java:124)
        at com.zimbra.cs.index.ZimbraQueryResultsImpl.hasNext(ZimbraQueryResultsImpl.java:93)
        at com.zimbra.cs.index.ItemPreloadingGrouper.bufferHits(ItemPreloadingGrouper.java:54)
        at com.zimbra.cs.index.BufferingResultsGrouper.peekNext(BufferingResultsGrouper.java:73)
        at com.zimbra.cs.index.FilteredQueryResults.peekNext(FilteredQueryResults.java:195)
        at com.zimbra.cs.index.FilteredQueryResults.hasNext(FilteredQueryResults.java:145)
        at com.zimbra.cs.index.ResultsPager.hasNext(ResultsPager.java:139)
        at com.zimbra.cs.service.mail.Search.putHits(Search.java:202)
        at com.zimbra.cs.service.mail.Search.handle(Search.java:127)
        at com.zimbra.soap.SoapEngine.dispatchRequest(SoapEngine.java:664)
        at com.zimbra.soap.SoapEngine.dispatch(SoapEngine.java:509)
        at com.zimbra.soap.SoapEngine.dispatch(SoapEngine.java:296)
        at com.zimbra.soap.SoapServlet.doWork(SoapServlet.java:308)
        at com.zimbra.soap.SoapServlet.doPost(SoapServlet.java:217)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
        at com.zimbra.cs.servlet.ZimbraServlet.service(ZimbraServlet.java:214)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:873)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1623)
        at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:214)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.CsrfFilter.doFilter(CsrfFilter.java:175)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.RequestStringFilter.doFilter(RequestStringFilter.java:54)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.SetHeaderFilter.doFilter(SetHeaderFilter.java:59)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ETagHeaderFilter.doFilter(ETagHeaderFilter.java:47)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ContextPathBasedThreadPoolBalancerFilter.doFilter(ContextPathBasedThreadPoolBalancerFilter.java:107)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ZimbraQoSFilter.doFilter(ZimbraQoSFilter.java:116)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at com.zimbra.cs.servlet.ZimbraInvalidLoginFilter.doFilter(ZimbraInvalidLoginFilter.java:117)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at org.eclipse.jetty.servlets.DoSFilter.doFilterChain(DoSFilter.java:482)
        at org.eclipse.jetty.servlets.DoSFilter.doFilter(DoSFilter.java:327)
        at org.eclipse.jetty.servlets.DoSFilter.doFilter(DoSFilter.java:297)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1610)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:540)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:146)
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:524)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:132)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:257)
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:1700)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextHandle(ScopedHandler.java:255)
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1345)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:203)
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:480)
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:1667)
        at org.eclipse.jetty.server.handler.ScopedHandler.nextScope(ScopedHandler.java:201)
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1247)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:144)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:220)
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:152)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:132)
        at org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:335)
        at org.eclipse.jetty.server.handler.gzip.GzipHandler.handle(GzipHandler.java:753)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:132)
        at org.eclipse.jetty.server.Server.handle(Server.java:505)
        at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:370)
        at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:267)
        at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:305)
        at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
        at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.onFillable(SslConnection.java:427)
        at org.eclipse.jetty.io.ssl.SslConnection.onFillable(SslConnection.java:321)
        at org.eclipse.jetty.io.ssl.SslConnection$2.succeeded(SslConnection.java:159)
        at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103)
        at org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117)
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:698)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:804)
        at java.lang.Thread.run(Thread.java:834)
```
**Expected behavior**
MasterSlaveConnectionManager.closeNodeConnections should throw an timeout exception if the same is not able to complete within a configured timeout.

**Actual behavior**
Thread hangs indefinitely at the request.

**Redis version**
5.0.5

**Redisson version**
3.10.7

**Redisson configuration**
nettyThreads=16
masterConnectionPoolSize=200
masterConnectionMinimumIdleSize=100
subscriptionConnectionPoolSize=200
subscriptionConnectionMinimumIdleSize=100
subscriptionsPerConnection=10
connectionTimeout=10000
retryInterval=3000
retryAttempts=10
keepAlive=true
tcpNoDelay=true
clusterScanInterval=2000
pingConnectionInterval=10000
",https://github.com/redisson/redisson/issues/2306,1.0,0.0,0.0,38
487,"threads blocked waiting on CountDownLatch
Hello,

We are facing an an issue where some threads get blocked indefinitely waiting on the CountDownLatch in `CommandAsyncService.get()`. Relevant section of the thread dump:
```
- waiting on java.util.concurrent.CountDownLatch$Sync@1f2311a9
at java.util.concurrent.locks.LockSupport.park(LockSupport.java: at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:
at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:
at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:
at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:232)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:186)
...
```
The reason for why the requests aren't able to complete isn't relevant here (we are deploying redis in kubernetes, and are working through various upgrade/failure scenarios that currently can result in severed connections). However, it's strange to me that the `CommandAsyncService.get()` method doesn't respect timeout configuration, and simply calls `l.await()`.
Is there any way around this? Please let me know if I am misunderstanding the situation.

### Expected behavior
`CommandAsyncService.get()` should throw an exception if the future is unable to complete within a timeout.

### Actual behavior
Many threads are hanging indefinitely in the `CommandAsyncService.get()` method.

### Redis version
5.0.5

### Redisson version
3.10.7

### Redisson configuration
nettyThreads=16
masterConnectionPoolSize=200
masterConnectionMinimumIdleSize=100
subscriptionConnectionPoolSize=200
subscriptionConnectionMinimumIdleSize=100
subscriptionsPerConnection=10
connectionTimeout=10000
retryInterval=3000
retryAttempts=10
keepAlive=true
tcpNoDelay=true
clusterScanInterval=2000
pingConnectionInterval=10000",https://github.com/redisson/redisson/issues/2304,1.0,0.0,0.0,38
488,"update link to missing update site
update site is not reachable
http://download.eclipse.org/tm/updates/4.0/GA
seems like this version was moved to
http://download.eclipse.org/tm/updates/OLD-STUFF/4.0/GA/",https://github.com/eclipse/n4js/issues/910,1.0,2.0,2.0,49
489,"v3.1/4.0: Javadoc-Fix for ChronoFormatter#toFormat()
In version v3.0, updating the javadoc was forgotten. Some new elements are missing in current javadoc describing the mapping from Time4J-elements to `DateFormat.Field`-constants.
",https://github.com/MenoData/Time4J/issues/267,1.0,2.0,2.0,45
188,"JUnit 4 is no longer on the compile classpath with Gradle
We've recently moved `spring-boot-starter-test` to JUnit 5 and the vintage engine brings JUnit 4 to keep backward compatibility.

Unfortunately, the junit dependency is defined in `runtime` scope so it is not available at compilation time with Gradle. 

We have no other choice than to add `junit` ourselves in our starter, which will make it harder to exclude JUnit 4 for applications that have migrated their tests.
",https://github.com/spring-projects/spring-boot/issues/16807,1.0,2.0,2.0,42
90,"DevTools can live lock during stop/restart
```
Full thread dump OpenJDK 64-Bit Server VM (25.141-b15 mixed mode):

""Attach Listener"" #41 daemon prio=9 os_prio=0 tid=0x00007f7d8c002000 nid=0xa331 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""Thread-9"" #37 prio=5 os_prio=0 tid=0x00007f7d6c1e6800 nid=0x1fb waiting for monitor entry [0x00007f7da5cf6000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.springframework.context.support.AbstractApplicationContext$1.run(AbstractApplicationContext.java:933)
	- waiting to lock <0x00000000836b91b8> (a java.lang.Object)

""SIGTERM handler"" #40 daemon prio=9 os_prio=0 tid=0x00007f7d8c001000 nid=0x1fa in Object.wait() [0x00007f7da680a000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x00000000db4526b0> (a org.springframework.context.support.AbstractApplicationContext$1)
	at java.lang.Thread.join(Thread.java:1252)
	- locked <0x00000000db4526b0> (a org.springframework.context.support.AbstractApplicationContext$1)
	at java.lang.Thread.join(Thread.java:1326)
	at java.lang.ApplicationShutdownHooks.runHooks(ApplicationShutdownHooks.java:106)
	at java.lang.ApplicationShutdownHooks$1.run(ApplicationShutdownHooks.java:46)
	at java.lang.Shutdown.runHooks(Shutdown.java:123)
	at java.lang.Shutdown.sequence(Shutdown.java:167)
	at java.lang.Shutdown.exit(Shutdown.java:212)
	- locked <0x00000000837edf28> (a java.lang.Class for java.lang.Shutdown)
	at java.lang.Terminator$1.handle(Terminator.java:52)
	at sun.misc.Signal$1.run(Signal.java:212)
	at java.lang.Thread.run(Thread.java:748)

""Thread-6"" #20 prio=5 os_prio=0 tid=0x00007f7d5c002000 nid=0x1c1 in Object.wait() [0x00007f7da732f000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x00000000da13f968> (a java.lang.Thread)
	at java.lang.Thread.join(Thread.java:1252)
	- locked <0x00000000da13f968> (a java.lang.Thread)
	at java.lang.Thread.join(Thread.java:1326)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stopAfter(FileSystemWatcher.java:194)
	- locked <0x00000000da0b6d18> (a java.lang.Object)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stop(FileSystemWatcher.java:177)
	at org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher.destroy(ClassPathFileSystemWatcher.java:95)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:576)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:552)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:953)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:521)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.destroySingletons(FactoryBeanRegistrySupport.java:227)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:960)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1035)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1011)
	at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:963)
	- locked <0x00000000836b91b8> (a java.lang.Object)
	at org.springframework.boot.devtools.restart.Restarter.stop(Restarter.java:311)
	at org.springframework.boot.devtools.restart.Restarter.lambda$restart$1(Restarter.java:250)
	at org.springframework.boot.devtools.restart.Restarter$$Lambda$199/713682444.call(Unknown Source)
	at org.springframework.boot.devtools.restart.Restarter$LeakSafeThread.run(Restarter.java:617)

""DestroyJavaVM"" #38 prio=5 os_prio=0 tid=0x00007f7dc800c800 nid=0x184 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""http-nio-auto-1-35746-AsyncTimeout"" #36 daemon prio=5 os_prio=0 tid=0x00007f7d789d3800 nid=0x1bb waiting on condition [0x00007f7d3befd000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at org.apache.coyote.AbstractProtocol$AsyncTimeout.run(AbstractProtocol.java:1211)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-Acceptor-0"" #35 daemon prio=5 os_prio=0 tid=0x00007f7d789d2000 nid=0x1ba runnable [0x00007f7d3bffe000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)
	at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)
	at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)
	- locked <0x00000000db2d9e68> (a java.lang.Object)
	at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:455)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-ClientPoller-1"" #34 daemon prio=5 os_prio=0 tid=0x00007f7d789cf800 nid=0x1b9 runnable [0x00007f7da414a000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
	- locked <0x00000000db381498> (a sun.nio.ch.Util$3)
	- locked <0x00000000db381488> (a java.util.Collections$UnmodifiableSet)
	- locked <0x00000000db381370> (a sun.nio.ch.EPollSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
	at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:793)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-ClientPoller-0"" #33 daemon prio=5 os_prio=0 tid=0x00007f7d789b5800 nid=0x1b8 runnable [0x00007f7da424b000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
	- locked <0x00000000db370b58> (a sun.nio.ch.Util$3)
	- locked <0x00000000db370b48> (a java.util.Collections$UnmodifiableSet)
	- locked <0x00000000db370a30> (a sun.nio.ch.EPollSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
	at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:793)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-10"" #32 daemon prio=5 os_prio=0 tid=0x00007f7d78999800 nid=0x1b7 waiting on condition [0x00007f7da434c000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-9"" #31 daemon prio=5 os_prio=0 tid=0x00007f7d78997800 nid=0x1b6 waiting on condition [0x00007f7da444d000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-8"" #30 daemon prio=5 os_prio=0 tid=0x00007f7d78995800 nid=0x1b5 waiting on condition [0x00007f7da454e000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-7"" #29 daemon prio=5 os_prio=0 tid=0x00007f7d78993800 nid=0x1b4 waiting on condition [0x00007f7da464f000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-6"" #28 daemon prio=5 os_prio=0 tid=0x00007f7d78991800 nid=0x1b3 waiting on condition [0x00007f7da4750000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-5"" #27 daemon prio=5 os_prio=0 tid=0x00007f7d7898f800 nid=0x1b2 waiting on condition [0x00007f7da4851000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-4"" #26 daemon prio=5 os_prio=0 tid=0x00007f7d7898d800 nid=0x1b1 waiting on condition [0x00007f7da4952000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-3"" #25 daemon prio=5 os_prio=0 tid=0x00007f7d7898b800 nid=0x1b0 waiting on condition [0x00007f7da4a53000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-2"" #24 daemon prio=5 os_prio=0 tid=0x00007f7d7898a000 nid=0x1af waiting on condition [0x00007f7da4b54000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""http-nio-auto-1-exec-1"" #23 daemon prio=5 os_prio=0 tid=0x00007f7d78988000 nid=0x1ae waiting on condition [0x00007f7da4c55000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x00000000db3100f8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
	at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)

""NioBlockingSelector.BlockPoller-1"" #22 daemon prio=5 os_prio=0 tid=0x00007f7d7896a800 nid=0x1ad runnable [0x00007f7da4d56000]
   java.lang.Thread.State: RUNNABLE
	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
	- locked <0x00000000db2db078> (a sun.nio.ch.Util$3)
	- locked <0x00000000db2daff0> (a java.util.Collections$UnmodifiableSet)
	- locked <0x00000000db2dae70> (a sun.nio.ch.EPollSelectorImpl)
	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
	at org.apache.tomcat.util.net.NioBlockingSelector$BlockPoller.run(NioBlockingSelector.java:339)

""Live Reload Server"" #21 daemon prio=5 os_prio=0 tid=0x00007f7d7895c000 nid=0x1ac runnable [0x00007f7da4e57000]
   java.lang.Thread.State: RUNNABLE
	at java.net.PlainSocketImpl.socketAccept(Native Method)
	at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)
	at java.net.ServerSocket.implAccept(ServerSocket.java:545)
	at java.net.ServerSocket.accept(ServerSocket.java:513)
	at org.springframework.boot.devtools.livereload.LiveReloadServer.acceptConnections(LiveReloadServer.java:146)
	at org.springframework.boot.devtools.livereload.LiveReloadServer$$Lambda$178/353302609.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:748)

""File Watcher"" #19 daemon prio=5 os_prio=0 tid=0x00007f7d78950800 nid=0x1aa waiting for monitor entry [0x00007f7da4f58000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stopAfter(FileSystemWatcher.java:186)
	- waiting to lock <0x00000000da0b6d18> (a java.lang.Object)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stop(FileSystemWatcher.java:177)
	at org.springframework.boot.devtools.classpath.ClassPathFileChangeListener.publishEvent(ClassPathFileChangeListener.java:70)
	at org.springframework.boot.devtools.classpath.ClassPathFileChangeListener.onChange(ClassPathFileChangeListener.java:64)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.fireListeners(FileSystemWatcher.java:305)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.updateSnapshots(FileSystemWatcher.java:298)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.scan(FileSystemWatcher.java:258)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.run(FileSystemWatcher.java:238)
	at java.lang.Thread.run(Thread.java:748)

""container-0"" #18 prio=5 os_prio=0 tid=0x00007f7d788c4800 nid=0x1a6 waiting on condition [0x00007f7da5259000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at org.apache.catalina.core.StandardServer.await(StandardServer.java:427)
	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer$1.run(TomcatWebServer.java:170)

""ContainerBackgroundProcessor[StandardEngine[Tomcat]]"" #17 daemon prio=5 os_prio=0 tid=0x00007f7d788c2000 nid=0x1a4 waiting on condition [0x00007f7da535a000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1355)
	at java.lang.Thread.run(Thread.java:748)

""Service Thread"" #8 daemon prio=9 os_prio=0 tid=0x00007f7dc80bd000 nid=0x190 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""C1 CompilerThread2"" #7 daemon prio=9 os_prio=0 tid=0x00007f7dc80b5800 nid=0x18f waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""C2 CompilerThread1"" #6 daemon prio=9 os_prio=0 tid=0x00007f7dc80b4000 nid=0x18e waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""C2 CompilerThread0"" #5 daemon prio=9 os_prio=0 tid=0x00007f7dc80b1000 nid=0x18d waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""Signal Dispatcher"" #4 daemon prio=9 os_prio=0 tid=0x00007f7dc80af000 nid=0x18c runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

""Finalizer"" #3 daemon prio=8 os_prio=0 tid=0x00007f7dc8086800 nid=0x18b in Object.wait() [0x00007f7da7cfb000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x000000008362dd98> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
	- locked <0x000000008362dd98> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

""Reference Handler"" #2 daemon prio=10 os_prio=0 tid=0x00007f7dc8081800 nid=0x18a in Object.wait() [0x00007f7da7dfc000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x000000008362dd00> (a java.lang.ref.Reference$Lock)
	at java.lang.Object.wait(Object.java:502)
	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
	- locked <0x000000008362dd00> (a java.lang.ref.Reference$Lock)
	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

""VM Thread"" os_prio=0 tid=0x00007f7dc807a000 nid=0x189 runnable 

""GC task thread#0 (ParallelGC)"" os_prio=0 tid=0x00007f7dc8022000 nid=0x185 runnable 

""GC task thread#1 (ParallelGC)"" os_prio=0 tid=0x00007f7dc8023800 nid=0x186 runnable 

""GC task thread#2 (ParallelGC)"" os_prio=0 tid=0x00007f7dc8025800 nid=0x187 runnable 

""GC task thread#3 (ParallelGC)"" os_prio=0 tid=0x00007f7dc8027000 nid=0x188 runnable 

""VM Periodic Task Thread"" os_prio=0 tid=0x00007f7dc80bf800 nid=0x191 waiting on condition 

JNI global references: 694
```

The two interesting threads are:

```
""File Watcher"" #19 daemon prio=5 os_prio=0 tid=0x00007f7d78950800 nid=0x1aa waiting for monitor entry [0x00007f7da4f58000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stopAfter(FileSystemWatcher.java:186)
	- waiting to lock <0x00000000da0b6d18> (a java.lang.Object)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stop(FileSystemWatcher.java:177)
	at org.springframework.boot.devtools.classpath.ClassPathFileChangeListener.publishEvent(ClassPathFileChangeListener.java:70)
	at org.springframework.boot.devtools.classpath.ClassPathFileChangeListener.onChange(ClassPathFileChangeListener.java:64)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.fireListeners(FileSystemWatcher.java:305)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.updateSnapshots(FileSystemWatcher.java:298)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.scan(FileSystemWatcher.java:258)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher$Watcher.run(FileSystemWatcher.java:238)
	at java.lang.Thread.run(Thread.java:748)
```

And:

```
""Thread-6"" #20 prio=5 os_prio=0 tid=0x00007f7d5c002000 nid=0x1c1 in Object.wait() [0x00007f7da732f000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x00000000da13f968> (a java.lang.Thread)
	at java.lang.Thread.join(Thread.java:1252)
	- locked <0x00000000da13f968> (a java.lang.Thread)
	at java.lang.Thread.join(Thread.java:1326)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stopAfter(FileSystemWatcher.java:194)
	- locked <0x00000000da0b6d18> (a java.lang.Object)
	at org.springframework.boot.devtools.filewatch.FileSystemWatcher.stop(FileSystemWatcher.java:177)
	at org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher.destroy(ClassPathFileSystemWatcher.java:95)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:256)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:576)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:552)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:953)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:521)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.destroySingletons(FactoryBeanRegistrySupport.java:227)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:960)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1035)
	at org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1011)
	at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:963)
	- locked <0x00000000836b91b8> (a java.lang.Object)
	at org.springframework.boot.devtools.restart.Restarter.stop(Restarter.java:311)
	at org.springframework.boot.devtools.restart.Restarter.lambda$restart$1(Restarter.java:250)
	at org.springframework.boot.devtools.restart.Restarter$$Lambda$199/713682444.call(Unknown Source)
	at org.springframework.boot.devtools.restart.Restarter$LeakSafeThread.run(Restarter.java:617)
```",https://github.com/spring-projects/spring-boot/issues/10496,1.0,0.0,0.0,45
117,"ExecutorServiceCancelOnPartitionMessageTask blocks partition thread during migrations 
How to reproduce: 

submit tasks from client to ExecutorService using `submitToKeyOwner` method: 

                    IExecutorService es = client.getExecutorService(""es1"");
                    Future result = es.submitToKeyOwner(new SimpleExecutorImpl(), partitionKey);

Then get the result using timeout. If it timeouts, cancel the task: 

                    try {
                        Object resultValue = result.get(20, TimeUnit.MILLISECONDS);
                    } catch (TimeoutException e) {
                        result.cancel(false);
                    } 

While continuously sending tasks from the client side, kill 1 of the members in the cluster to initiate partition migrations. 


-------------



ExecutorServiceCancelOnPartitionMessageTask creates CancellationOperation which runs on partition threads. 
However, it doesn't retry when the partition is migrating. See below stack traces. 

The result is stuck migration operation. 

Why don't we call `ExecutorService.cancel`  instead of creating CancellationOperation which runs on partition threads? 

The task is routed to the member using the partition ID. However, the partition could migrate to another member but the task would still be running at the same member. In this case, cancel operation would route to the wrong member to cancel the task. Wdyt? 

Blocked partition thread: 

```
""hz._hzInstance_1_oz.partition-operation.thread-0"" #17 prio=5 os_prio=31 tid=0x00007f9d8a313800 nid=0x6203 waiting on condition [0x0000700005ed8000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)
	at com.hazelcast.spi.impl.AbstractInvocationFuture.get(AbstractInvocationFuture.java:161)
	at com.hazelcast.client.impl.protocol.task.executorservice.AbstractExecutorServiceCancelMessageTask.call(AbstractExecutorServiceCancelMessageTask.java:52)
	at com.hazelcast.client.impl.protocol.task.AbstractCallableMessageTask.processMessage(AbstractCallableMessageTask.java:35)
	at com.hazelcast.client.impl.protocol.task.AbstractMessageTask.initializeAndProcessMessage(AbstractMessageTask.java:129)
	at com.hazelcast.client.impl.protocol.task.AbstractMessageTask.run(AbstractMessageTask.java:109)
	at com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:163)
	at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:159)
	at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:127)
	at com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.run(OperationThread.java:110)
```

Blocked migration thread: 

```
""hz._hzInstance_1_oz.migration"" #38 prio=5 os_prio=31 tid=0x00007f9d8a312800 nid=0x5f03 waiting on condition [0x0000700005bcf000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)
	at com.hazelcast.spi.impl.AbstractInvocationFuture.get(AbstractInvocationFuture.java:161)
	at com.hazelcast.internal.partition.impl.MigrationManager$MigrateTask.executeMigrateOperation(MigrationManager.java:1116)
	at com.hazelcast.internal.partition.impl.MigrationManager$MigrateTask.run(MigrationManager.java:1003)
	at com.hazelcast.internal.partition.impl.MigrationThread.processTask(MigrationThread.java:122)
	at com.hazelcast.internal.partition.impl.MigrationThread.doRun(MigrationThread.java:98)
	at com.hazelcast.internal.partition.impl.MigrationThread.run(MigrationThread.java:67)
```


",https://github.com/hazelcast/hazelcast/issues/15497,1.0,0.0,0.0,46
251,"Netty buffer leak during failover and RBatch object exection
",https://github.com/redisson/redisson/issues/1896,1.0,1.0,1.0,46
264,"NullPointerException in LocalTransport
I made a LocalTransport server/client pair.
I made them share a LocalEventLoopGroup(1)

Server.channelRead() calls ctx.close()

I then get:
    [WARN] SingleThreadEventExecutor - Unexpected exception from an event executor:  <java.lang.NullPointerException>java.lang.NullPointerException
        at io.netty.channel.local.LocalChannel.access$300(LocalChannel.java:44)
        at io.netty.channel.local.LocalChannel$4.run(LocalChannel.java:169)
        at io.netty.channel.local.LocalEventLoop.run(LocalEventLoop.java:33)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
        at java.lang.Thread.run(Thread.java:724)

That's the connectPromise.

If I allow the EventLoopGroup 2 threads, then it does not throw NPE.

But I really want 1 thread to synchronize logging, as I'm in a test suite.
",https://github.com/netty/netty/issues/2144,1.0,0.0,0.0,40
6,"2.4.2 RC1: Connection leak detection false positive
I tried 2.4.2 RC1 in replacement to 2.4.1.

Without any changes to the app, HikariCP reports a connection leak after pool-initialization.
But there is no leaking connection: one connection in pool, one idle, one connection to the database.

Excerpt from log (pool configuration and leak alert):

```
[#| 16.10.2015 14:01:05.887 | ... | DEBUG com.zaxxer.hikari.HikariConfig 
dev - configuration:
allowPoolSuspension.............false
autoCommit......................true
catalog.........................
connectionInitSql...............
connectionTestQuery.............
connectionTimeout...............2000
dataSource......................
dataSourceClassName.............org.postgresql.ds.PGSimpleDataSource
dataSourceJNDI..................
dataSourceProperties............{serverName=…, socketTimeout=15, user=…, databaseName=…, tcpKeepAlive=true, prepareThreshold=0, password=<masked>, portNumber=, loginTimeout=15}
driverClassName.................
healthCheckProperties...........{}
healthCheckRegistry.............
idleTimeout.....................1200000
initializationFailFast..........true
isolateInternalQueries..........false
jdbc4ConnectionTest.............false
jdbcUrl.........................
leakDetectionThreshold..........10000
maxLifetime.....................43200000
maximumPoolSize.................50
metricRegistry..................com.codahale.metrics.MetricRegistry@148da145
metricsTrackerFactory...........
minimumIdle.....................0
password........................<masked>
poolName........................dev
readOnly........................false
registerMbeans..................true
scheduledExecutorService........
threadFactory……………….<customClass>$1@21540445
transactionIsolation............
username........................
validationTimeout...............2000
dev - is starting.
dev - Connection.setNetworkTimeout() is not supported (...)
|#]

[#| 16.10.2015 14:01:05.927 | … | DEBUG com.zaxxer.hikari.pool.HikariPool 
dev - Added connection org.postgresql.jdbc4.Jdbc4Connection@3a4a6161
|#]

[#| 16.10.2015 14:01:05.928 | ... | DEBUG com.zaxxer.hikari.pool.PoolBase 
dev - Closing connection org.postgresql.jdbc4.Jdbc4Connection@3a4a6161: (connection evicted by user)
|#]


…<no action from app>...


[#| 16.10.2015 14:01:15.948 | ... | WARN  com.zaxxer.hikari.pool.ProxyLeakTask 
Connection leak detection triggered for connection org.postgresql.jdbc4.Jdbc4Connection@3a4a6161, stack trace follows
java.lang.Exception: Apparent connection leak detected
    at com.zaxxer.hikari.pool.HikariPool.<init>(HikariPool.java:138) ~[HikariCP-2.4.2-RC1.jar:na]
    at com.zaxxer.hikari.HikariDataSource.<init>(HikariDataSource.java:71) ~[HikariCP-2.4.2-RC1.jar:na]
    ...
|#]

[#| 16.10.2015 14:01:35.897 | … | DEBUG com.zaxxer.hikari.pool.HikariPool 
Before cleanup  pool dev stats (total=1, active=0, idle=1, waiting=0)
```
",https://github.com/brettwooldridge/HikariCP/issues/465,1.0,1.0,1.0,47
174,"Installing from the P2 site is broken
Jay Jay,

You gave me incomplete instructions...

Cannot complete the install because one or more required items could not be found.
  Software being installed: ICE Infrastructure Feature 2.1.8.201604122238 (org.eclipse.ice.feature.group 2.1.8.201604122238)
  Missing requirement: EAVP Datastructures 2.1.8.201604082008 (org.eclipse.eavp.viz.datastructures 2.1.8.201604082008) requires 'bundle org.eclipse.nebula.visualization.widgets 1.0.0' but it could not be found
  Cannot satisfy dependency:
    From: BatteryML 2.1.8.201604122238 (org.eclipse.ice.caebat.batml 2.1.8.201604122238)
    To: bundle org.eclipse.ice.datastructures 0.0.0
  Cannot satisfy dependency:
    From: ICEDataStructures 2.1.8.201604122238 (org.eclipse.ice.datastructures 2.1.8.201604122238)
    To: package org.eclipse.eavp.viz.datastructures.VizObject 0.0.0
  Cannot satisfy dependency:
    From: ICE Infrastructure Feature 2.1.8.201604122238 (org.eclipse.ice.feature.group 2.1.8.201604122238)
    To: org.eclipse.ice.caebat.batml [2.1.8.201604122238]

First I had to install the Nebula project from http://download.eclipse.org/technology/nebula/snapshot
This let me install EAVP, but not ICE from the repository you provided:

Cannot complete the install because one or more required items could not be found.
  Software being installed: ICE Infrastructure Feature 2.1.8.201604122238 (org.eclipse.ice.feature.group 2.1.8.201604122238)
  Missing requirement: Client 2.1.8.201604122238 (org.eclipse.ice.client 2.1.8.201604122238) requires 'bundle com.sun.jersey 1.17.0' but it could not be found
  Cannot satisfy dependency:
    From: ICE Infrastructure Feature 2.1.8.201604122238 (org.eclipse.ice.feature.group 2.1.8.201604122238)
    To: org.eclipse.ice.client [2.1.8.201604122238]

Although I found and downloaded http://repo1.maven.org/maven2/com/sun/jersey/jersey-archive/1.19.1/jersey-archive-1.19.1.zip and http://repo1.maven.org/maven2/com/sun/jersey/jersey-archive/1.17/jersey-archive-1.17.zip, I don't know how to make this available under Eclipse. 
Can you give me instructions?
What else is required for installing ICE?
I have installed Eclipse through the PTP environment which has C++ and Fortran but not Java. Should I install the Java environment for this?

Thanks
Norbert
",https://github.com/eclipse/ice/issues/190,1.0,2.0,2.0,45
82,"Deadlock in SSLHandler
Hi,

I suspect I found a bug in the SSLHandler class.
One of our integration tests fails systematically; from the stacktraces it appears to be caused by a thread deadlock.

I've tried with several versions, from 3.4 on - it happens with all of them, including 3.6.4.Final-SNAPSHOT build #122 which is the one relative to the stacktraces below; 

To give an idea of the scenario the netty server is serving several https download which are interrupted by the clients before termination.

<pre>
Found one Java-level deadlock:
=============================
""com.spreaker.mi.station.download.HttpDownloader@4a6f19d5"":
  waiting to lock monitor 7f839e82c058 (object 7db0310f0, a java.lang.Object),
  which is held by ""New I/O worker #15""
""New I/O worker #15"":
  waiting to lock monitor 7f839b131e60 (object 7db031130, a java.util.LinkedList),
  which is held by ""com.spreaker.mi.station.download.HttpDownloader@4a6f19d5""

Java stack information for the threads listed above:
===================================================
""com.spreaker.mi.station.download.HttpDownloader@4a6f19d5"":
    at org.jboss.netty.handler.ssl.SslHandler.wrap(SslHandler.java:959)
    - waiting to lock <7db0310f0> (a java.lang.Object)
    - locked <7db031130> (a java.util.LinkedList)
    at org.jboss.netty.handler.ssl.SslHandler.handleDownstream(SslHandler.java:627)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelDownstreamHandler.writeRequested(SimpleChannelDownstreamHandler.java:108)
    at org.jboss.netty.handler.timeout.WriteTimeoutHandler.writeRequested(WriteTimeoutHandler.java:159)
    at org.jboss.netty.channel.SimpleChannelDownstreamHandler.handleDownstream(SimpleChannelDownstreamHandler.java:70)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:60)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.handler.execution.ExecutionHandler.handleDownstream(ExecutionHandler.java:186)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at com.spreaker.mi.net.icecast.StreamingServerStatsdHandler.writeRequested(StreamingServerStatsdHandler.java:92)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at com.spreaker.mi.core.net.http.HttpServerProtocolHandler._writeRequested(HttpServerProtocolHandler.java:152)
    at com.spreaker.mi.core.net.http.HttpServerProtocolHandler.writeRequested(HttpServerProtocolHandler.java:92)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.Channels.write(Channels.java:725)
    at com.spreaker.mi.core.net.DebugChunkedWriteHandler.flush(DebugChunkedWriteHandler.java:271)
    at com.spreaker.mi.core.net.DebugChunkedWriteHandler.resumeTransfer(DebugChunkedWriteHandler.java:85)
    at com.spreaker.mi.core.net.PacketChunkedStreamHandler.onResumeTransfer(PacketChunkedStreamHandler.java:49)
    at com.spreaker.mi.core.net.PacketChunkedStream.addPacket(PacketChunkedStream.java:114)
    at com.spreaker.mi.station.download.HttpDownloader._downloadBytes(HttpDownloader.java:83)
    at com.spreaker.mi.station.download.HttpEngine.run(HttpEngine.java:131)
    at java.lang.Thread.run(Thread.java:680)
""New I/O worker #15"":
    at org.jboss.netty.handler.ssl.SslHandler$6.run(SslHandler.java:1562)
    - waiting to lock <7db031130> (a java.util.LinkedList)
    at org.jboss.netty.channel.socket.ChannelRunnableWrapper.run(ChannelRunnableWrapper.java:40)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.executeInIoThread(AbstractNioWorker.java:69)
    at org.jboss.netty.channel.socket.nio.NioWorker.executeInIoThread(NioWorker.java:36)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.executeInIoThread(AbstractNioWorker.java:55)
    at org.jboss.netty.channel.socket.nio.NioWorker.executeInIoThread(NioWorker.java:36)
    at org.jboss.netty.channel.socket.nio.AbstractNioChannelSink.execute(AbstractNioChannelSink.java:34)
    at org.jboss.netty.channel.DefaultChannelPipeline.execute(DefaultChannelPipeline.java:632)
    at org.jboss.netty.handler.ssl.SslHandler.channelClosed(SslHandler.java:1557)
    at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:88)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:560)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:787)
    at org.jboss.netty.channel.SimpleChannelHandler.channelClosed(SimpleChannelHandler.java:216)
    at org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:106)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:560)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:555)
    at org.jboss.netty.channel.Channels.fireChannelClosed(Channels.java:468)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.close(AbstractNioWorker.java:351)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:254)
    - locked <7db031868> (a java.lang.Object)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:145)
    at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
    at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:775)
    at org.jboss.netty.channel.SimpleChannelHandler.writeRequested(SimpleChannelHandler.java:292)
    at org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:254)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:587)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:780)
    at org.jboss.netty.channel.Channels.write(Channels.java:725)
    at org.jboss.netty.channel.Channels.write(Channels.java:686)
    at org.jboss.netty.handler.ssl.SslHandler.wrapNonAppData(SslHandler.java:1144)
    at org.jboss.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1233)
    - locked <7db0310f0> (a java.lang.Object)
    at org.jboss.netty.handler.ssl.SslHandler.decode(SslHandler.java:910)
    at org.jboss.netty.handler.codec.frame.FrameDecoder.callDecode(FrameDecoder.java:425)
    at org.jboss.netty.handler.codec.frame.FrameDecoder.messageReceived(FrameDecoder.java:303)
    at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:70)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:560)
    at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:787)
    at org.jboss.netty.channel.SimpleChannelHandler.messageReceived(SimpleChannelHandler.java:142)
    at org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:88)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:560)
    at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:555)
    at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:268)
    at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:255)
    at org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:88)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.process(AbstractNioWorker.java:107)
    at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:312)
    at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:88)
    at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)
    at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)
    at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)
    at java.lang.Thread.run(Thread.java:680)
</pre>


Please let me know if any additional information is required or if this issue might be caused by a misuse of the SSLHandler class on our side.

Thanks,

Andrea.
",https://github.com/netty/netty/issues/1181,1.0,0.0,0.0,42
455,"connectionTimeout implementation default different from documentation default
The documentation says the default `connectionTimeout` is 30000 ms.
The implementation actually defaults the `connectionTimeout` to 5000 ms.

Also, the JavaDoc for `connectionTimeout` is actually the JavaDoc for `connectionTestQuery`
",https://github.com/brettwooldridge/HikariCP/issues/68,1.0,2.0,2.0,53
13,"Adding DefaultHttpHeaders to itself creates infinite loop
Example:

```
public void test() {
    HttpHeaders headers = new DefaultHttpHeaders();
    headers.add(""foo"", ""bar"");
    headers.add(headers);
    // This will never end
    headers.forEach(entry -> {});
}
```
",https://github.com/netty/netty/issues/4265,1.0,3.0,3.0,54
83,"Deadlock on overlord with HttpRemoteTaskRunner
We noticed deadlocks on the overlord in our test cluster in HttpRemoteTaskRunner:

```
""hrtr-pending-tasks-runner-0"" #193 daemon prio=5 os_prio=0 tid=0x00007fc5a8020000 nid=0x72ec waiting for monitor entry [0x00007fc5644b4000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner.runTaskOnWorker(HttpRemoteTaskRunner.java:379)
        - waiting to lock <0x00000000c1544c10> (a java.lang.Object)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner.lambda$addPendingTaskToExecutor$7(HttpRemoteTaskRunner.java:1005)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner$$Lambda$133/748833484.run(Unknown Source)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
```

```
java.lang.Thread.State: BLOCKED (on object monitor)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner.getKnownTasks(HttpRemoteTaskRunner.java:1111)
        - waiting to lock <0x00000000c1544c10> (a java.lang.Object)
        at io.druid.indexing.overlord.TaskQueue.manage(TaskQueue.java:232)
        at io.druid.indexing.overlord.TaskQueue.access$000(TaskQueue.java:69)
        at io.druid.indexing.overlord.TaskQueue$1.run(TaskQueue.java:136)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
```

```
""HttpRemoteTaskRunner-worker-sync-4"" #116 daemon prio=5 os_prio=0 tid=0x00007fc588018800 nid=0x724c waiting for monitor entry [0x00007fc569801000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at io.druid.server.coordination.ChangeRequestHttpSyncer.stop(ChangeRequestHttpSyncer.java:138)
        - waiting to lock <0x00000000c1544980> (a io.druid.concurrent.LifecycleLock)
        at io.druid.indexing.overlord.hrtr.WorkerHolder.stop(WorkerHolder.java:333)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner.removeWorker(HttpRemoteTaskRunner.java:532)
        - locked <0x00000000c1540300> (a java.util.concurrent.ConcurrentHashMap)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner.lambda$scheduleSyncMonitoring$2(HttpRemoteTaskRunner.java:642)
        - locked <0x00000000c1540300> (a java.util.concurrent.ConcurrentHashMap)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner$$Lambda$90/1851975649.run(Unknown Source)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
```

```
java.lang.Thread.State: BLOCKED (on object monitor)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner.taskAddedOrUpdated(HttpRemoteTaskRunner.java:1174)
        - waiting to lock <0x00000000c1544c10> (a java.lang.Object)
        at io.druid.indexing.overlord.hrtr.HttpRemoteTaskRunner$$Lambda$87/935105358.taskAddedOrUpdated(Unknown Source)
        at io.druid.indexing.overlord.hrtr.WorkerHolder$2.notifyListener(WorkerHolder.java:449)
        at io.druid.indexing.overlord.hrtr.WorkerHolder$2.deltaSync(WorkerHolder.java:442)
        at io.druid.server.coordination.ChangeRequestHttpSyncer$1.onSuccess(ChangeRequestHttpSyncer.java:269)
        - locked <0x00000000c1543b50> (a io.druid.concurrent.LifecycleLock)
        at io.druid.server.coordination.ChangeRequestHttpSyncer$1.onSuccess(ChangeRequestHttpSyncer.java:225)
        at com.google.common.util.concurrent.Futures$4.run(Futures.java:1181)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
```",https://github.com/apache/druid/issues/6201,1.0,0.0,0.0,48
12,"Add jsp-api to security sample
",https://github.com/spring-projects/spring-session/issues/279,1.0,2.0,2.0,39
420,"WebSocket08FrameDecoder may leak memory if channel is closed before the full frame was received
Morning, i was looking through logfiles from our application and found this (after running without exceptions for days):

```
22:48:33.120 WARN  io.netty.util.ResourceLeakDetector - LEAK: ByteBuf was GC'd before being released correctly.  The following stack trace shows where the leaked object was created, rather than where you failed to release it.
io.netty.util.ResourceLeakException: io.netty.buffer.UnpooledUnsafeDirectByteBuf@201e42a1
at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:174) ~[thruput-0.6.2.jar:na]
at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:116) ~[thruput-0.6.2.jar:na]
at io.netty.buffer.UnpooledUnsafeDirectByteBuf.<init>(UnpooledUnsafeDirectByteBuf.java:72) ~[thruput-0.6.2.jar:na]
at io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:49) ~[thruput-0.6.2.jar:na]
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:132) ~[thruput-0.6.2.jar:na]
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:123) ~[thruput-0.6.2.jar:na]
at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:60) ~[thruput-0.6.2.jar:na]
at io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder.decode(WebSocket08FrameDecoder.java:268) ~[thruput-0.6.2.jar:na]
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:362) ~[thruput-0.6.2.jar:na]
at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:131) [thruput-0.6.2.jar:na]
at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:337) [thruput-0.6.2.jar:na]
at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:323) [thruput-0.6.2.jar:na]
at io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:253) [thruput-0.6.2.jar:na]
at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:337) [thruput-0.6.2.jar:na]
at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:323) [thruput-0.6.2.jar:na]
at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:785) [thruput-0.6.2.jar:na]
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:100) [thruput-0.6.2.jar:na]
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:478) [thruput-0.6.2.jar:na]
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:447) [thruput-0.6.2.jar:na]
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:341) [thruput-0.6.2.jar:na]
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101) [thruput-0.6.2.jar:na]
at java.lang.Thread.run(Thread.java:724) [na:1.7.0_40]
```

I do not have any more information than this :(
",https://github.com/netty/netty/issues/1874,1.0,1.0,1.0,37
11,"AbstractChannel#filterOutboundMessage may mask writing a released empty buffer
AbstractChannel attempts to ""filter"" messages which are written [1]. A goal of this process is to copy from heap to direct if necessary. However implementations of this method [2][3] may translate a buffer with 0 readable bytes to EMPTY_BUFFER. This may mask a user error where an empty buffer is written but already released.

[1] https://github.com/netty/netty/blob/4.1/transport/src/main/java/io/netty/channel/AbstractChannel.java#L877
[2] https://github.com/netty/netty/blob/4.1/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java#L252
[3] https://github.com/netty/netty/blob/4.1/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java#L306",https://github.com/netty/netty/issues/7383,1.0,1.0,1.0,42
462,"groovy scripting docs are buggy for 'multiValued'
The documentation (https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting-groovy.html#_doc_value_properties_and_methods) states that you can do this:

```
doc['field_name'].multiValued
    A boolean indicating that the field has several values within the corpus. 
```

This does not work though, we don't have any actual code to support it. I don't think we need it either, since someone could just look at `doc['field_name'].size() > 1` or a number of other ways, but we should fix the docs.
",https://github.com/elastic/elasticsearch/issues/18164,1.0,2.0,2.0,44
111,"Entities not building after updating to beta12
After upgrading to beta12, my project will no longer build.

I receive the following in the gradle build messages:

```
Error:Execution failed for task ':app:compileDebugJavaWithJavac'.
> java.lang.NoSuchMethodError: com.squareup.javapoet.TypeSpec.classBuilder(Lcom/squareup/javapoet/ClassName;)Lcom/squareup/javapoet/TypeSpec$Builder;
```

I can have `requery`, and `requery-android` at beta12 and `requery-processor` at beta11 and the project will build fine. But upgrading `requery-processor` to beta12 will stop it from building.
",https://github.com/requery/requery/issues/75,1.0,2.0,2.0,35
146,"Got following exception when i try upload large file(25MB) using netty HttpUpload example. 
4 Jul, 2013 12:06:47 PM io.netty.util.ResourceLeakDetector reportLeak
WARNING: LEAK: ByteBuf was GC'd before being released correctly.
io.netty.util.ResourceLeakException: io.netty.buffer.DefaultCompositeByteBuf@b82368
    at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:158)
    at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
    at io.netty.buffer.DefaultCompositeByteBuf.<init>(DefaultCompositeByteBuf.java:80)
    at io.netty.buffer.Unpooled.wrappedBuffer(Unpooled.java:301)
    at io.netty.buffer.Unpooled.wrappedBuffer(Unpooled.java:238)
    at io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.offer(HttpPostRequestDecoder.java:363)
    at io.netty.example.http.upload.HttpUploadServerHandler.messageReceived(HttpUploadServerHandler.java:185)
    at io.netty.example.http.upload.HttpUploadServerHandler.messageReceived(HttpUploadServerHandler.java:1)
    at io.netty.channel.SimpleChannelInboundHandler.messageReceived(SimpleChannelInboundHandler.java:84)
    at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
    at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
    at io.netty.handler.codec.ByteToMessageDecoder.messageReceived(ByteToMessageDecoder.java:178)
    at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
    at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
    at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:347)
    at io.netty.channel.DefaultChannelPipeline.fireMessageReceived(DefaultChannelPipeline.java:780)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:92)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:489)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:358)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
    at java.lang.Thread.run(Unknown Source)

I forgot to mention one more result that i got with the same example.
I configured the HttpDataFectory to useDisk = false;
I didn't get any exception but received file have size less than the actual file size(in case of media file but worked correctly with text file with size of around 7MB).
",https://github.com/netty/netty/issues/1516,1.0,1.0,1.0,46
257,"NormalMemoryRegionCache's arraysize is over booked
When create NormalMemoryRegionCache for PoolThreadCache. The array size is decided by:
        int max = Math.min(area.chunkSize, maxCachedBufferCapacity);
        int arraySize = Math.max(1, max / area.pageSize);

So most likely it is decided by maxCachedBufferCapacity/area.pageSize, with maxCachedBufferCapacity=2M the array size will be 2^8 = 256.

when we try to get normal cache the index is pre-processed by log2():
PoolThreadCache.cacheForNormal():
        int idx = log2(normCapacity >> numShiftsNormalHeap);
        return cache(normalHeapCaches, idx);

A 2M cache entry will get from the 8th cache bin(start from 0).

The space for NormalMemoryRegionCache is over booked, though it will not impact correctness(just a little performance..).
",https://github.com/netty/netty/issues/2925,1.0,1.0,1.0,40
86,"DefaultChannelPool leaks IdleChannels
`DefaultChannelPool#removeAll` fails to properly remove entry from partition as it tries to remove a `Channel` instead of an `IdleChannel`.",https://github.com/AsyncHttpClient/async-http-client/issues/1461,1.0,1.0,1.0,48
469,"junit-platform-suite-api should not have a dependency on junit-platform-commons
## Overview

The `junit-platform-suite-api` currently has a direct dependency on `junit-platform-commons` which it does not need.

## Deliverables

- [x] Remove `junit-platform-suite-api`'s dependency on `junit-platform-commons`.

",https://github.com/junit-team/junit5/issues/1690,1.0,2.0,2.0,43
114,"EntryEvent toString returns nulls
Running the sample code on 3.3 for EventListeners (ListeningMember,ModifyingMember)

The EntryEvent returns nulls in the toString().

If you access the properties directly via get it returns correctly.
",https://github.com/hazelcast/hazelcast/issues/3633,1.0,3.0,3.0,43
143,"Generated code doesn't compile when custom type mapper maps to a nullable primitive type
The generated `hashCode()` attempts to take `Integer.hashCode(myEntity.getMyIntField())` even though `myEntity.getMyIntField()` returns an `OptionalInt`.",https://github.com/speedment/speedment/issues/628,1.0,3.0,3.0,38
88,"Dependencies missing from shade plugin in spring-boot-starter-parent
In 1.5.8:

```                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-shade-plugin</artifactId>
                    <dependencies>
                        <dependency>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                            <version>1.5.8.RELEASE</version>
                        </dependency>
                    </dependencies>
...
```


in 2.0.0

```                <plugin>
                    <artifactId>maven-shade-plugin</artifactId>
                    <executions>
```


(no dependencies)",https://github.com/spring-projects/spring-boot/issues/11200,1.0,2.0,2.0,47
419,"WebSocket08FrameDecoder leaks ByteBuf when payload is masked
",https://github.com/netty/netty/issues/1878,1.0,1.0,1.0,51
104,"EdgeRouterFactory yields memory leak
The `GraphConfigurator` creates a new `EdgeRouterFactory` for every layout run:
```
algorithmAssembler.setPhase(LayeredPhases.P5_EDGE_ROUTING,
        EdgeRouterFactory.factoryFor(lgraph.getProperty(LayeredOptions.EDGE_ROUTING)));
```

The created edge router instance, say `SplineEdgeRouter`, is then cached within the `AlgorithmAssembler`. Since it's a new factory every time, caching is broken in `AlgorithmAssembler#retrieveProcessor`. 

```
if (enableCaching) {
            if (cache.containsKey(factory)) {
[...]
```",https://github.com/eclipse/elk/issues/252,1.0,1.0,1.0,46
107,"Empty trash task should use thread pool executor
`emptyTrashTask` should use the thread pool so it is run parallel.
",https://github.com/Automattic/simplenote-android/issues/213,1.0,0.0,0.0,53
53,"Cleanup build
Please remove the following lines from the target platform definition:
https://github.com/eclipse/elk/blob/3c28c0639585ebeab6fffab12d7e86cd581019ef/build/org.eclipse.elk.targetplatform/org.eclipse.elk.targetplatform.target#L30-L33

Besides, please change 
https://github.com/eclipse/elk/blob/3c28c0639585ebeab6fffab12d7e86cd581019ef/build/org.eclipse.elk.targetplatform/org.eclipse.elk.targetplatform.target#L28
to http://download.eclipse.org/modeling/emft/mwe/updates/releases/2.10.0/ or .../2.11.1",https://github.com/eclipse/elk/issues/487,1.0,2.0,2.0,42
95,"Distributions no longer deployed
Usually I can find a full dist of the spring releases at:
https://maven.springframework.org/release/org/springframework/spring/
5.2.4 does not seem to have been posted despite most of the modules now being available on Maven central.",https://github.com/spring-projects/spring-framework/issues/24605,1.0,2.0,2.0,46
360,"SniHandler#replaceHandler() may leak (reference counted) SslContexts
The SniHandler#select()/AsyncMapper#map() methods execute asynchronously and by the time the returned Future completes the client is possibly no longer connected.

The #selection field will be set but probably after #channelInactive() (i.e. can't really do anything with it) and the #replace() call on the ChannelPipeline will probably throw a NoSuchElementException.

I have no good suggestion how to fix it. There is an opportunity to cancel the future and it could try to decrement the refCnt if the Future completes successfully but the client has disconnected in the meantime. 

Given SniHandler is a one-shot handler maybe something along the lines of this?!

``` java
class SniHandler {
  private Promsie<SslContext> promise;

  void handlerAdded(ChannelHandlerContext ctx) {
    promsie = ctx.newPromise();
  }

  void channelInactive(ChannelHandlerContext ctx) {
    promsie.cancel(true);
    promsie.addFutureListener(... release() on success ...);
    ctx.fireChannelInactive();
  }

  void select(...) {
    mapping.map(hostname, promsie).addFutureListener(... replaceHandler() ...);
  }
}
```
",https://github.com/netty/netty/issues/5678,1.0,1.0,1.0,48
313,"Regex support on /metrics returns ""not found"" if metrics value is null
Regex support added in boot v1.3 does not handle correctly null metrics value due to :

https://github.com/spring-projects/spring-boot/blob/8ca5635b69109fba898a094abd5970c906d29060/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/mvc/MetricsMvcEndpoint.java#L75

Consequently, it results in a 404 HTTP error code.
",https://github.com/spring-projects/spring-boot/issues/4552,1.0,3.0,3.0,54
46,"Cannot use dependency due to new release management
Introduced in #1286

We now get:

```
Failed to collect dependencies at com.graphhopper:graphhopper-reader-osm:jar:0.10-SNAPSHOT: Failed to read artifact descriptor for com.graphhopper:graphhopper-reader-osm:jar:0.10-SNAPSHOT: Failure to find com.graphhopper:graphhopper-parent:pom:${revision} in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced -> [Help 1]
```

for all projects trying to use the dependencies at e.g. maven central. Which is ugly and could be fixed with a 'flat' pom: https://maven.apache.org/maven-ci-friendly.html

Related: http://blog.kiwitype.com/2017/maven-versioning-in-a-continuous-delivery-pipeline/",https://github.com/graphhopper/graphhopper/issues/1288,1.0,2.0,2.0,42
312,"RedissonList's Iterator Race Conditions
RedissonList iterator as it tries to keep ""up to date"" with data has a race condition in which if between the .hasNext() and the .next() call the set is emptied the list will throw NoSuchElementException.

---
## Unit Test

private static final String LIST_NAME = ""TEST_LIST"";
private static boolean failed;

```
@Ignore
class Delete implements Runnable {

    public void run() {
        // remove one item
        RList<Object> list = redisson.getList(LIST_NAME);
        if (!list.isEmpty()) {
            Iterator<Object> iter = list.iterator();
            if (iter.hasNext()) {
                iter.next();
                iter.remove();
            }
        }
    }
}

@Ignore
class Add implements Runnable {
    int i = 0;

    public void run() {
        // add items up to place up to one in list
        RList<Object> list = redisson.getList(LIST_NAME);
        if (list.isEmpty()) {
            list.add(""Entry:"" + (i++));

        }
    }
}

@Ignore
class Loop implements Runnable {
    public void run() {
        try {
            RList<Object> list = redisson.getList(LIST_NAME);
            if (!list.isEmpty()) {
                // implicit iterator
                for (@SuppressWarnings(""unused"")
                Object o : list) {
                }
            }
        } catch (Exception e) {
            RedissonListTest.failed = true;
            e.printStackTrace();
        }
    }
}

class ThousandAndOneThread extends Thread {
    public ThousandAndOneThread(Runnable r) {
        this.r = r;
    }

    boolean dead = false;
    int nightsLeft = 1001;
    Runnable r;

    public void run() {
        // while shahrazad still is alive
        while (!dead && nightsLeft > 0) {
            nightsLeft--;

            // do runnable
            r.run();

            // take a nap
            try {
                Thread.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
                break;
            }
        }

        dead = true;
    }

    // Kill shahrazad
    public void kill() {
        dead = true;
    }

    // if i am done
    public boolean isDone() {
        return dead;
    }
}

@Test
public void testIteratorAfterDelete() {
    for (int i = 0; i < 4; i++) {
        // make runnables
        Delete d = new Delete();
        Add a = new Add();
        Loop l = new Loop();

        // make threads
        ThousandAndOneThread aT = new ThousandAndOneThread(a);
        ThousandAndOneThread dT = new ThousandAndOneThread(l);
        ThousandAndOneThread lT = new ThousandAndOneThread(d);

        // start threads
        aT.start();
        dT.start();
        lT.start();

        // monitor threads
        while (true) {
            if (failed) {
                fail(""Exception occured, in child thread"");
            }
            if (lT.isDone() || dT.isDone() || aT.isDone()) {
                System.out.println(""All done!"" + i);
                aT.kill();
                dT.kill();
                lT.kill();
                break;
            }
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
                aT.kill();
                dT.kill();
                lT.kill();
                fail(""fail on "" + i);
            }
        }
    }
}
```

---
## Additional Information

This also effects RedissonSet, but much less likely to hit the race condition. It causes RedissonSet line 96 to throw a null pointer exception. 

This is akin to issue #104 
",https://github.com/redisson/redisson/issues/106,1.0,0.0,0.0,44
364,"Spring Session docs PDF do not display sample code
<!--
For Security Vulnerabilities, please use https://pivotal.io/security#reporting
-->

<!--
Thanks for raising a Spring Session issue. Please provide a brief description of your problem along with the version of Spring Session that you are using. If possible, please also consider putting together a sample application that reproduces the issue.
-->

This is the case for version `2.3.0.RC1`.
Instead of the sample code, the following error message is shown:
```
Unresolved directive in guides/java-redis.adoc - include::{samples-dir}springsession-sample-javaconfig-redis/src/main/java/sample/Initializer.java[tags=class]
```
",https://github.com/spring-projects/spring-session/issues/1603,1.0,2.0,2.0,44
365,"Spurious ""LEAK: ByteBuf was GC'd before being released correctly"" message?
I have a server using ProtobufEncoder and ProtobufDecoder to encode and decode messages with Netty 4.0.2 (Linux, OpenJDK 7 64-bit).

I'm finding when I have 50 client connections each sending 1000 messages/second and all connections are closed simultaneously, I often (but not always) see this error message in the server.  This error message only occurs when many client connections are shutdown quickly, not during normal steady state operation.

```
15:37:45,221 {nioEventLoopGroup-3-8} WARN  ResourceLeakDetector - LEAK: ByteBuf was GC'd before being released correctly.  The following stack trace shows where the leaked object was created, rather than who failed to release it where.
io.netty.util.ResourceLeakException: io.netty.buffer.UnpooledUnsafeDirectByteBuf@286d15b6
    at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:161)
    at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
    at io.netty.buffer.UnpooledUnsafeDirectByteBuf.<init>(UnpooledUnsafeDirectByteBuf.java:72)
    at io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:49)
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:130)
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:121)
    at io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:74)
    at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:107)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite0(DefaultChannelHandlerContext.java:698)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite(DefaultChannelHandlerContext.java:684)
    at io.netty.channel.DefaultChannelHandlerContext.write(DefaultChannelHandlerContext.java:677)
    at io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:114)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite0(DefaultChannelHandlerContext.java:698)
    at io.netty.channel.DefaultChannelHandlerContext.access$1700(DefaultChannelHandlerContext.java:27)
    at io.netty.channel.DefaultChannelHandlerContext$18.run(DefaultChannelHandlerContext.java:689)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:353)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:366)
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
    at java.lang.Thread.run(Thread.java:724)
```

My server code is here: https://github.com/aaronriekenberg/Simple-Message-Service/blob/master/sms-broker/src/main/java/org/aaron/sms/broker/SMSBrokerTCPServer.java

The ChannelInitializer in the server is below.  ServerHandler extends SimpleChannelInboundHandler, so I believe all pooling/reference counting should be handled automatically.  The only writes I'm doing in the server use instances of protobuf objects.

``` java
    private class ServerChannelInitializer extends ChannelInitializer<Channel> {

        @Override
        protected void initChannel(Channel ch) throws Exception {
            final ChannelPipeline p = ch.pipeline();
            p.addLast(""logger"", new LoggingHandler(LogLevel.DEBUG));

            p.addLast(""frameEncoder"", new LengthFieldPrepender(
                    SMSProtocolConstants.MESSAGE_HEADER_LENGTH_BYTES));

            p.addLast(""frameDecoder"", new LengthFieldBasedFrameDecoder(
                    SMSProtocolConstants.MAX_MESSAGE_LENGTH_BYTES, 0,
                    SMSProtocolConstants.MESSAGE_HEADER_LENGTH_BYTES, 0,
                    SMSProtocolConstants.MESSAGE_HEADER_LENGTH_BYTES));

            p.addLast(""protobufEncoder"", new ProtobufEncoder());

            p.addLast(""protobufDecoder"", new ProtobufDecoder(
                    SMSProtocol.ClientToBrokerMessage.getDefaultInstance()));

            p.addLast(""serverHandler"", new ServerHandler());
        }
    }
```
",https://github.com/netty/netty/issues/1624,1.0,1.0,1.0,44
311,"Redisson 3.5.7 memory leak with locks
I'm using RLock and seeing memory leak via org.redisson.client.handler.CommandPubSubDecoder 
 
![image](https://user-images.githubusercontent.com/443442/37062360-0f201f60-214b-11e8-81a2-d2fab78261c4.png)


Retained objects delta between heap dumps taken apart
![image 1](https://user-images.githubusercontent.com/443442/37062341-01519f12-214b-11e8-8d35-4bc50413fd50.png)

Around 10MB leak per day
![image 2](https://user-images.githubusercontent.com/443442/37062443-5150dfdc-214b-11e8-944f-fb46ec393693.png)
",https://github.com/redisson/redisson/issues/1326,1.0,1.0,1.0,48
222,"Memory leak
A lot of following exceptions we get in JetBrains:

```
Editor of class com.intellij.openapi.editor.impl.EditorImpl hasn't been released:

com.intellij.openapi.util.TraceableDisposable.ObjectNotDisposedException: See stack trace responsible for creation of unreleased object below 
	at com.intellij.openapi.editor.impl.EditorImpl.<init>(EditorImpl.java:156)
	at com.intellij.openapi.editor.impl.EditorFactoryImpl.createEditor(EditorFactoryImpl.java:220)
	at com.intellij.openapi.editor.impl.EditorFactoryImpl.createEditor(EditorFactoryImpl.java:195)
	at mobi.hsz.idea.gitignore.util.Utils.createPreviewEditor(Utils.java:369)
	at mobi.hsz.idea.gitignore.ui.untrackFiles.UntrackFilesDialog.createCenterPanel(UntrackFilesDialog.java:197)
	at com.intellij.openapi.ui.DialogWrapper.init(DialogWrapper.java:1308)
	at mobi.hsz.idea.gitignore.ui.untrackFiles.UntrackFilesDialog.<init>(UntrackFilesDialog.java:139)
	at mobi.hsz.idea.gitignore.TrackedIgnoredFilesComponent$1.hyperlinkUpdate(TrackedIgnoredFilesComponent.java:125)
	at com.intellij.notification.impl.ui.NotificationsUtil$1.hyperlinkUpdate(NotificationsUtil.java:155)
	at javax.swing.JEditorPane.fireHyperlinkUpdate(JEditorPane.java:342)
	at javax.swing.text.html.HTMLEditorKit$LinkController.activateLink(HTMLEditorKit.java:875)
	at javax.swing.text.html.HTMLEditorKit$LinkController.mouseClicked(HTMLEditorKit.java:674)
	at java.awt.AWTEventMulticaster.mouseClicked(AWTEventMulticaster.java:270)
	at java.awt.Component.processMouseEvent(Component.java:6544)
	at javax.swing.JComponent.processMouseEvent(JComponent.java:3324)
	at java.awt.Component.processEvent(Component.java:6306)
	at java.awt.Container.processEvent(Container.java:2237)
	at java.awt.Component.dispatchEventImpl(Component.java:4897)
	at java.awt.Container.dispatchEventImpl(Container.java:2295)
	at java.awt.Component.dispatchEvent(Component.java:4719)
	at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4889)
	at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4535)
	at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4467)
	at java.awt.Container.dispatchEventImpl(Container.java:2281)
	at java.awt.Window.dispatchEventImpl(Window.java:2746)
	at java.awt.Component.dispatchEvent(Component.java:4719)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:764)
	at java.awt.EventQueue.access$500(EventQueue.java:98)
	at java.awt.EventQueue$3.run(EventQueue.java:715)
	at java.awt.EventQueue$3.run(EventQueue.java:709)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)
	at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:90)
	at java.awt.EventQueue$4.run(EventQueue.java:737)
	at java.awt.EventQueue$4.run(EventQueue.java:735)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:734)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:821)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:645)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:365)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)

```",https://github.com/JetBrains/idea-gitignore/issues/373,1.0,1.0,1.0,56
220,"Memory Leak when I try to create client
<!--
Please consider to take commercial 24x7 support included in PRO version https://redisson.pro
-->

### Expected behavior
It should't have memory leak.
### Actual behavior
```
[main] ERROR io.netty.util.ResourceLeakDetector  - LEAK: HashedWheelTimer.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 
Created at:
	io.netty.util.HashedWheelTimer.<init>(HashedWheelTimer.java:272)
	io.netty.util.HashedWheelTimer.<init>(HashedWheelTimer.java:216)
	io.netty.util.HashedWheelTimer.<init>(HashedWheelTimer.java:195)
	org.redisson.connection.MasterSlaveConnectionManager.initTimer(MasterSlaveConnectionManager.java:318)
	org.redisson.connection.MasterSlaveConnectionManager.<init>(MasterSlaveConnectionManager.java:161)
	org.redisson.connection.SingleConnectionManager.<init>(SingleConnectionManager.java:34)
	org.redisson.config.ConfigSupport.createConnectionManager(ConfigSupport.java:192)
	org.redisson.Redisson.<init>(Redisson.java:122)
	org.redisson.Redisson.create(Redisson.java:159)
	test.main(test.java:32)
```

### Steps to reproduce or test case
```java=
        Codec stringCodec = new StringCodec();

        for (int i = 0; i < 10; i++) {
            RedissonClient client;
            Config config = new Config();
            config.useSingleServer().setAddress(RedisConfig.Address);
            config.useSingleServer().setPassword(RedisConfig.Password);
            config.setCodec(stringCodec);
            client = Redisson.create(config);

            BatchOptions options = BatchOptions.defaults();
            RBatch pipe = client.createBatch(options);

            pipe.getBucket(""test"", stringCodec).getAsync();
            BatchResult res = pipe.execute();

            System.out.println(res.getResponses().get(0));

            client.shutdown();

            System.gc();
        }

```

### Redis version
4.0.10
### Redisson version
3.7.5
### Redisson configuration
```
Config config = new Config();
config.useSingleServer().setAddress(RedisConfig.Address);
config.useSingleServer().setPassword(RedisConfig.Password);
config.setCodec(stringCodec);
client = Redisson.create(config);
```
",https://github.com/redisson/redisson/issues/1584,1.0,1.0,1.0,47
175,"Intermittent dead lock when java.util.logging uses a LoggingHandler writtin on top of Netty.
```
Found one Java-level deadlock:
=============================
""New I/O worker #1"":
  waiting to lock monitor 0x0000000000e2a278 (object 0x00000006fafed930, a java.util.logging.LogManager),
  which is held by ""main""
""main"":
  waiting to lock monitor 0x0000000000e28c78 (object 0x00000006fafee5e0, a java.util.logging.LogManager$LoggerContext),
  which is held by ""New I/O worker #1""

Java stack information for the threads listed above:
===================================================
""New I/O worker #1"":
at java.util.logging.LogManager.drainLoggerRefQueueBounded(LogManager.java:811)
- waiting to lock <0x00000006fafed930> (a java.util.logging.LogManager)
at java.util.logging.LogManager$LoggerContext.addLocalLogger(LogManager.java:511)
- locked <0x00000006fafee5e0> (a java.util.logging.LogManager$LoggerContext)
at java.util.logging.LogManager.addLogger(LogManager.java:848)
at java.util.logging.LogManager.demandLogger(LogManager.java:405)
at java.util.logging.Logger.demandLogger(Logger.java:317)
at java.util.logging.Logger.getLogger(Logger.java:361)
at org.jboss.netty.logging.JdkLoggerFactory.newInstance(JdkLoggerFactory.java:30)
at org.jboss.netty.logging.InternalLoggerFactory.getInstance(InternalLoggerFactory.java:76)
at org.jboss.netty.logging.InternalLoggerFactory.getInstance(InternalLoggerFactory.java:69)
at org.jboss.netty.channel.socket.nio.SelectorUtil.<clinit>(SelectorUtil.java:28)
at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:199)
at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:90)
at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)
at org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)
at org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
at java.lang.Thread.run(Thread.java:722)

""main"":
at java.util.logging.LogManager$LoggerContext.findLogger(LogManager.java:489)
- waiting to lock <0x00000006fafee5e0> (a java.util.logging.LogManager$LoggerContext)
at java.util.logging.LogManager.getLogger(LogManager.java:910)
at java.util.logging.LogManager.demandLogger(LogManager.java:400)
at java.util.logging.Logger.demandLogger(Logger.java:317)
at java.util.logging.Logger.getLogger(Logger.java:361)
at org.jboss.netty.logging.JdkLoggerFactory.newInstance(JdkLoggerFactory.java:30)
at org.jboss.netty.logging.InternalLoggerFactory.getInstance(InternalLoggerFactory.java:76)
at org.jboss.netty.logging.InternalLoggerFactory.getInstance(InternalLoggerFactory.java:69)
at org.jboss.netty.channel.socket.nio.NioClientSocketPipelineSink.<clinit>(NioClientSocketPipelineSink.java:36)
at org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory.<init>(NioClientSocketChannelFactory.java:208)
at org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory.<init>(NioClientSocketChannelFactory.java:185)
...
at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
at java.lang.Class.newInstance0(Class.java:374)
at java.lang.Class.newInstance(Class.java:327)
at java.util.logging.LogManager$4.run(LogManager.java:685)
at java.security.AccessController.doPrivileged(Native Method)
at java.util.logging.LogManager.loadLoggerHandlers(LogManager.java:678)
at java.util.logging.LogManager.initializeGlobalHandlers(LogManager.java:1249)
- locked <0x00000006fafed930> (a java.util.logging.LogManager)
at java.util.logging.LogManager.access$1300(LogManager.java:150)
at java.util.logging.LogManager$RootLogger.getHandlers(LogManager.java:1332)
at java.util.logging.Logger.log(Logger.java:564)
at java.util.logging.Logger.doLog(Logger.java:586)
at java.util.logging.Logger.log(Logger.java:609)
at java.util.logging.Logger.info(Logger.java:1128)
...
```
",https://github.com/netty/netty/issues/1701,1.0,0.0,0.0,46
42,"Cannot build root project on Windows
### Summary

Command `gradle build` failed with `String index out of range: -1` in `settings.gradle' line: 64`
### Actual Behavior

```
:buildSrc:compileJava UP-TO-DATE
:buildSrc:compileGroovy
:buildSrc:processResources UP-TO-DATE
:buildSrc:classes
:buildSrc:jar UP-TO-DATE
:buildSrc:assemble UP-TO-DATE
:buildSrc:compileTestJava UP-TO-DATE
:buildSrc:compileTestGroovy UP-TO-DATE
:buildSrc:processTestResources UP-TO-DATE
:buildSrc:testClasses UP-TO-DATE
:buildSrc:test UP-TO-DATE
:buildSrc:check UP-TO-DATE
:buildSrc:build UP-TO-DATE

FAILURE: Build failed with an exception.

* Where:
Settings file 'D:\private\github\spring-security\settings.gradle' line: 64

* What went wrong:
A problem occurred evaluating settings 'spring-security'.
> String index out of range: -1

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
```
### Expected Behavior

Project build succesfully
### Configuration

Windows 7, Gradle 2.10
### Version

Current master branch
",https://github.com/spring-projects/spring-security/issues/3852,1.0,2.0,2.0,42
372,"StringDecoder buffer leak related to maxInMemorySize limit
Backport of gh-24339",https://github.com/spring-projects/spring-framework/issues/24346,1.0,1.0,1.0,43
373,"StringDecoder buffer leak related to maxInMemorySize limit
This was discovered while working on implementing the same type of limit for `ServerSentEventsMessageReader` which depends on `StringDecoder` to split the stream into lines (see #24312). 

When a single input buffer contains multiple lines in which case slices for each line are retained, and if one of the earlier lines exceeds the limit, then subsequent lines are not released. This is due to a suspected issue with  `concatMapIterable` not respecting `doOnDiscard`. I've added a https://github.com/reactor/reactor-core/issues/1925#issuecomment-573630082 related to that. 

The goal for this issue is to add a workaround.",https://github.com/spring-projects/spring-framework/issues/24339,1.0,1.0,1.0,41
356,"SingleThreadEventExecutor.invokeAll() can deadlock
`SingleThreadEventExecutor` (and `AbstractEventExecutor`) does not override the `invokeAll()` method of `AbstractExecutorService`.

I found an interesting code in `AbstractExecutorService.invokeAll()`:

``` java
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
        if (tasks == null)
            throw new NullPointerException();
        long nanos = unit.toNanos(timeout);
        ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            for (Callable<T> t : tasks)
                futures.add(newTaskFor(t));

            final long deadline = System.nanoTime() + nanos;
            final int size = futures.size();

            // Interleave time checks and calls to execute in case
            // executor doesn't have any/much parallelism.
            for (int i = 0; i < size; i++) {
                execute((Runnable)futures.get(i));
                nanos = deadline - System.nanoTime();
                if (nanos <= 0L)
                    return futures;
            }

            for (int i = 0; i < size; i++) {
                Future<T> f = futures.get(i);
                if (!f.isDone()) {
                    if (nanos <= 0L)
                        return futures;
                    try {
                        f.get(nanos, TimeUnit.NANOSECONDS);
```

Do you see it submits a task (wrapped by a Future) and then call `Future.get()` on it? i.e. It will dead lock itself if it's not multi-threaded.
",https://github.com/netty/netty/issues/5507,1.0,0.0,0.0,43
374,"Subscription connection leak in PubSubConnectionEntry::removeListener
We have a production system using Redisson to handle notification. However, recently we constantly run into subscription connection exhausted issue. After investigation, I found Redisson doesn't release the subscription connection after the last listener is removed. 

Eventually, this issue is caused by the following line. It seems ConcurrentLinedQueue doesn't fully implement equals method to compare 2 linked list. Therefore, an empty linked list will never equals to another empty linked list, which eventually leaks all subscription connections.

```
public void removeListener(String channelName, RedisPubSubListener listener) {

  channelListeners.remove(channelName, new ConcurrentLinkedQueue<RedisPubSubListener>());

}
```

This is a very urgent issue to us. Any help or workaround will be greatly appreciated.
",https://github.com/redisson/redisson/issues/237,1.0,1.0,1.0,39
137,"Fix potential thread safe problem in InterceptorScope
InterceptorScopePool Field of DefaultProfilerPluginContext is not thread safe.

fixed version : 1.6.0-RC2",https://github.com/naver/pinpoint/issues/2259,1.0,0.0,0.0,46
224,"Memory leak in HlsMediaChunk
Hello.
We have m3u8 file format such as:
```

#EXTM3U
#EXT-X-STREAM-INF:BANDWIDTH=490000,RESOLUTION=640x360
http://XXX.XXX.XX.XXX:31213/MEDIA/76336503.....583609776254/161/4161/
#EXT-X-STREAM-INF:BANDWIDTH=1500000,RESOLUTION=720x576
http://XXX.XXX.XX.XXX:31213/MEDIA/76336503.....583609776254/161/3161/
#EXT-X-STREAM-INF:BANDWIDTH=2500000,RESOLUTION=1280x720
http://XXX.XXX.XX.XXX:31213/MEDIA/76336503.....583609776254/161/2161/

```
Each EXT-X-STREAM-INF tag link to file like:
```
#EXTM3U
#EXT-X-TARGETDURATION:5
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:35156
#EXT-X-START:TIME-OFFSET=-25,PRECISE=YES
#EXT-X-KEY:METHOD=AES-128,URI=""http://XXX.XXX.XX.XXX:02444/xxXXXXX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/191/2191/aeskey_191_
#EXTINF:5,
http://XXX.XXX.XX.XXX:XXXXX/SSEGMENT/3020314583628416652818934133893/191/2191/seg_XXXXX.ts
#EXTINF:5,
http://XXX.XXX.XX.XXX:XXXXX/SSEGMENT/6545456465456456465454564/191/2191/seg_191_XXXXX.ts
#EXTINF:5,
http://XXX.XXX.XX.XXX:XXXXX/SSEGMENT/6545456465456456465454564/191/2191/seg_191_XXXXX.ts
#EXTINF:5,
http://XXX.XXX.XX.XXX:XXXXX/SSEGMENT/6545456465456456465454564/191/2191/seg_191_XXXXX.ts
#EXTINF:5,
http://XXX.XXX.XX.XXX:XXXXX/SSEGMENT/6545456465456456465454564/191/2191/seg_191_XXXXX.ts
```
Large heap set to true.
After 2-3 hours of playing we have this video freeze and log is - [Log2.zip](https://github.com/google/ExoPlayer/files/701610/Log2.zip)

If we set large heap to false, then video freezes much faster and then we have out of memory exception.
",https://github.com/google/ExoPlayer/issues/2319,1.0,1.0,1.0,49
64,"ConcurrentModificationException
Hi- 

I just got this stack trace from Intellij 16.1.1:

```
null
java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)
    at java.util.ArrayList$Itr.next(ArrayList.java:851)
    at com.intellij.ide.bookmarks.BookmarkManager$2.documentCreated(BookmarkManager.java:100)
    at com.intellij.psi.impl.PsiDocumentManagerBase.fireDocumentCreated(PsiDocumentManagerBase.java:600)
    at com.intellij.psi.impl.PsiDocumentManagerImpl$1.fileContentLoaded(PsiDocumentManagerImpl.java:80)
    at sun.reflect.GeneratedMethodAccessor31.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.util.messages.impl.MessageBusConnectionImpl.deliverMessage(MessageBusConnectionImpl.java:117)
    at com.intellij.util.messages.impl.MessageBusImpl.doPumpMessages(MessageBusImpl.java:372)
    at com.intellij.util.messages.impl.MessageBusImpl.pumpMessages(MessageBusImpl.java:359)
    at com.intellij.util.messages.impl.MessageBusImpl.sendMessage(MessageBusImpl.java:338)
    at com.intellij.util.messages.impl.MessageBusImpl.access$200(MessageBusImpl.java:42)
    at com.intellij.util.messages.impl.MessageBusImpl$2.invoke(MessageBusImpl.java:226)
    at com.sun.proxy.$Proxy21.fileContentLoaded(Unknown Source)
    at sun.reflect.GeneratedMethodAccessor31.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at com.intellij.openapi.fileEditor.impl.FileDocumentManagerImpl.a(FileDocumentManagerImpl.java:136)
    at com.intellij.openapi.fileEditor.impl.FileDocumentManagerImpl.access$000(FileDocumentManagerImpl.java:86)
    at com.intellij.openapi.fileEditor.impl.FileDocumentManagerImpl$1.invoke(FileDocumentManagerImpl.java:114)
    at com.sun.proxy.$Proxy21.fileContentLoaded(Unknown Source)
    at com.intellij.openapi.fileEditor.impl.FileDocumentManagerImpl.getDocument(FileDocumentManagerImpl.java:215)
    at com.intellij.psi.SingleRootFileViewProvider.getDocument(SingleRootFileViewProvider.java:437)
    at com.intellij.psi.SingleRootFileViewProvider$VirtualFileContent.getText(SingleRootFileViewProvider.java:594)
    at com.intellij.psi.SingleRootFileViewProvider.getContents(SingleRootFileViewProvider.java:417)
    at com.intellij.psi.impl.source.PsiFileImpl.getText(PsiFileImpl.java:398)
    at mobi.hsz.idea.gitignore.IgnoreManager$5$1.run(IgnoreManager.java:437)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

I'm using .ignore 1.3.3.
",https://github.com/JetBrains/idea-gitignore/issues/221,1.0,0.0,0.0,47
229,"Memory leaking when using ALPN
We're experiencing a slow memory leak with 0.7.1 when using ALPN and TLS. The server is built and started with this code : 

```
NettyServerBuilder builder = NettyServerBuilder.forPort(port);
definitions.forEach(builder::addService);
SslContext context = SslContextBuilder.forServer(keyCertPathprivateKeyPath).build();
builder.sslContext(context);
ServerImpl server = builder.build();
server.start();
```

This is the alpn version that we're using.
-Xbootclasspath/p:/usr/lib/java/alpn-boot-8.1.3.v20150130.jar""

Running a heap dump, we're seeing a huge amount of SSLEngineImpl objects stored in a concurrent hash map : 

![image](https://cloud.githubusercontent.com/assets/9012046/8503526/2c2acda0-21c9-11e5-9dfe-ba599b324c12.png)

The server is running behind a Amazon ELB. This might be related since the Amazon load balancer would open connections every once in a while to the server and to ping and make sure the server is live. Unfortunately it takes a long time to replicate, the server would run out of memory after 36 hours or so, but it doesn't seem like the number of requests 
",https://github.com/grpc/grpc-java/issues/598,1.0,1.0,1.0,51
228,"Memory leak when using closeOnJvmShutdown (eg. any tmp map)
You have each engine register a shutdown hook with an anonymous class creation. Each of those threads has a reference to the engine being made (not that leaking threads themselves is great). These are kept in a special jdk store and will prevent garbage collection. You can unregister shutdown hooks if you keep a reference to them or you could lazily register a single static hook equipped with something similar to a listenable future and add/remove things to/from it.

Definitely not what you want to happen if you naively try to do something like create a temporary map for disk backed sorts.
",https://github.com/jankotek/mapdb/issues/272,1.0,1.0,1.0,42
332,"River: Failure to reallocate river to another node on rivers node failure
When a node that a river is running on fails, the river is not allocated to a different node.
",https://github.com/elastic/elasticsearch/issues/850,1.0,3.0,3.0,46
334,"RunProcess signal handling isn't thread-safe
If you run an app and then kill it with `CTRL-C` it may report an NPE during shutdown. Here's an example from using `mvn spring-boot:run`:

```
[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.1.0.BUILD-SNAPSHOT:run (default-cli) on project spring-boot-sample-ws: Could not exec java: NullPointerException -> [Help 1]

org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.1.0.BUILD-SNAPSHOT:run (default-cli) on project spring-boot-sample-ws: Could not exec java
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:216)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:108)
    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:76)
    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)
    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:116)
    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:361)
    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:155)
    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:584)
    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:213)
    at org.apache.maven.cli.MavenCli.main(MavenCli.java:157)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
Caused by: org.apache.maven.plugin.MojoExecutionException: Could not exec java
    at org.springframework.boot.maven.RunMojo.run(RunMojo.java:172)
    at org.springframework.boot.maven.RunMojo.execute(RunMojo.java:134)
    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:133)
    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
    ... 19 more
Caused by: java.lang.NullPointerException
    at org.springframework.boot.loader.tools.RunProcess.run(RunProcess.java:78)
    at org.springframework.boot.loader.tools.RunProcess.run(RunProcess.java:52)
    at org.springframework.boot.maven.RunMojo.run(RunMojo.java:168)
    ... 22 more
```

The problem is that there's a race between the signal handler setting `this.process` to `null` on one thread while another thread in `run()` that was blocked on `this.process.waitFor()` then tries to call `this.process.exitValue()`. If the signal handling thread gets in first and manages to null out `this.process` the call to `exitValue()` will NPE.

The fix is to remove the call to `this.process.exitValue()` from `run()` and use the value returned from `this.process.waitFor()` instead.
",https://github.com/spring-projects/spring-boot/issues/1061,1.0,0.0,0.0,36
326,"Resource leaks related to ClusterViewListenerService.clusterListeningEndpoints
While investigating a Jet OOME, we've realized there can be issues related to `ClusterViewListenerService.clusterListeningEndpoints`.

First of all, there were cca 27000 `TcpIpConnection` instances, but just about 20 of them were alive. The size of `clusterListeningEndpoints` map was about 25000 entries. (@olukas can provide the original heapdump).

We didn't find the reason for this behavior, but we realized there can be a resource leak in `com.hazelcast.client.impl.ClientEndpointImpl.destroy()` E.g. when a `logout` throws a `LoginException` or another problem jumps in before removing endpoint from the map.

https://github.com/hazelcast/hazelcast/blob/fdc6a205b2b6f50e01d21a263c373a0894ad2e67/hazelcast/src/main/java/com/hazelcast/client/impl/ClientEndpointImpl.java#L214-L231",https://github.com/hazelcast/hazelcast/issues/16482,1.0,1.0,1.0,46
226,"Memory leak when setOptions() fails while accepting a new connection.
",https://github.com/netty/netty/issues/129,1.0,1.0,1.0,47
324,"Resource leak in WebSocket08FrameDecoder
tim@tim-laptop ~/projects/vert-x/vertx-examples/src/raw/java $ vertx run wsperf/PerfClient.java
Starting perf client
Received data on all conns
LEAK: ByteBuf was GC'd before being released correctly. 
io.netty.util.ResourceLeakException: io.netty.buffer.UnpooledUnsafeDirectByteBuf@6f83405
at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.(ResourceLeakDetector.java:158)
at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
at io.netty.buffer.UnpooledUnsafeDirectByteBuf.(UnpooledUnsafeDirectByteBuf.java:72)
at io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:49)
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:130)
at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:121)
at io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:58)
at io.netty.handler.codec.http.websocketx.WebSocket08FrameDecoder.decode(WebSocket08FrameDecoder.java:259)
at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:356)
at io.netty.handler.codec.ByteToMessageDecoder.messageReceived(ByteToMessageDecoder.java:138)
at io.netty.channel.DefaultChannelHandlerContext.invokeMessageReceived(DefaultChannelHandlerContext.java:379)
at io.netty.channel.DefaultChannelHandlerContext.fireMessageReceived(DefaultChannelHandlerContext.java:364)
at io.netty.channel.DefaultChannelPipeline.fireMessageReceived(DefaultChannelPipeline.java:786)
at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:120)
at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:489)
at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:464)
at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:358)
at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101)
at java.lang.Thread.run(Thread.java:722)

See also:
https://github.com/vert-x/vert.x/issues/667
",https://github.com/netty/netty/issues/1507,1.0,1.0,1.0,43
323,"Resource leak in DefaultChannelHandlerContext when bridge is used.
13:37:26.255 [testsuite-aio-worker-4-3] WARN  io.netty.util.ResourceLeakDetector - LEAK: ByteBuf was GC'd before being released correctly.
io.netty.util.ResourceLeakException: io.netty.buffer.PooledUnsafeDirectByteBuf@5b8367ac
    at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:156) ~[netty-common-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:101) ~[netty-common-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.PooledByteBuf.<init>(PooledByteBuf.java:42) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.PooledUnsafeDirectByteBuf.<init>(PooledUnsafeDirectByteBuf.java:36) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.PoolArena$DirectArena.newByteBuf(PoolArena.java:388) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:93) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:190) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:130) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:121) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:74) ~[netty-buffer-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.ChannelHandlerUtil.allocate(ChannelHandlerUtil.java:171) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext$NextBridgeFeeder.<init>(DefaultChannelHandlerContext.java:1661) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext$NextInboundBridgeFeeder.<init>(DefaultChannelHandlerContext.java:1694) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext$NextInboundBridgeFeeder.<init>(DefaultChannelHandlerContext.java:1694) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext.nextInBridgeFeeder(DefaultChannelHandlerContext.java:635) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext.nextInboundByteBuffer(DefaultChannelHandlerContext.java:606) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelPipeline.inboundByteBuffer(DefaultChannelPipeline.java:765) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.socket.aio.AioSocketChannel.doBeginRead(AioSocketChannel.java:340) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.AbstractChannel$AbstractUnsafe.beginRead(AbstractChannel.java:802) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelPipeline$HeadHandler.read(DefaultChannelPipeline.java:1140) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext.invokeRead0(DefaultChannelHandlerContext.java:1235) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext.invokeRead(DefaultChannelHandlerContext.java:1218) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelHandlerContext.read(DefaultChannelHandlerContext.java:1212) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelPipeline.read(DefaultChannelPipeline.java:934) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.AbstractChannel.read(AbstractChannel.java:291) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelPipeline.fireChannelActive(DefaultChannelPipeline.java:819) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.aio.AbstractAioChannel$DefaultAioUnsafe.connectSuccess(AbstractAioChannel.java:160) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.socket.aio.AioSocketChannel$ConnectHandler.completed0(AioSocketChannel.java:524) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.socket.aio.AioSocketChannel$ConnectHandler.completed0(AioSocketChannel.java:520) ~[netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.aio.AioCompletionHandler$3.run(AioCompletionHandler.java:77) [netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.channel.aio.AioEventLoop.run(AioEventLoop.java:81) [netty-transport-4.0.0.CR2-SNAPSHOT.jar:na]
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:109) [netty-common-4.0.0.CR2-SNAPSHOT.jar:na]
    at java.lang.Thread.run(Thread.java:722) [na:1.7.0_17]
",https://github.com/netty/netty/issues/1298,1.0,1.0,1.0,43
61,"Concurrent INSERTs and DELETEs cause deadlock.
## Expected behavior and actual behavior

Concurrent INSERTs and DELETEs cause deadlock.
![img](http://i.imgur.com/SzjrjA4.png)

Stacktrace (taken with jvisualvm)

```
Found one Java-level deadlock:
=============================
""Thread-7"":
  waiting for ownable synchronizer 0x00000000d59c41d0, (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync),
  which is held by ""Thread-6""
""Thread-6"":
  waiting for ownable synchronizer 0x00000000d59c41a0, (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync),
  which is held by ""Thread-7""

Java stack information for the threads listed above:
===================================================
""Thread-7"":
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  <0x00000000d59c41d0> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)
    at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:943)
    at com.orientechnologies.common.concur.lock.OOneEntryPerKeyLockManager.acquireLock(OOneEntryPerKeyLockManager.java:173)
    at com.orientechnologies.common.concur.lock.OOneEntryPerKeyLockManager.acquireLock(OOneEntryPerKeyLockManager.java:100)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.OAtomicOperationsManager.acquireExclusiveLockTillOperationComplete(OAtomicOperationsManager.java:464)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.OAtomicOperationsManager.startAtomicOperation(OAtomicOperationsManager.java:175)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.OAtomicOperationsManager.startAtomicOperation(OAtomicOperationsManager.java:140)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.base.ODurableComponent.startAtomicOperation(ODurableComponent.java:123)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.OClusterPositionMap.remove(OClusterPositionMap.java:411)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.OPaginatedCluster.deleteRecord(OPaginatedCluster.java:806)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.doDeleteRecord(OAbstractPaginatedStorage.java:3205)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.deleteRecord(OAbstractPaginatedStorage.java:1151)
    at com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx.executeDeleteRecord(ODatabaseDocumentTx.java:2139)
    at com.orientechnologies.orient.core.tx.OTransactionNoTx.deleteRecord(OTransactionNoTx.java:274)
    at com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx.delete(ODatabaseDocumentTx.java:2563)
    at com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx.delete(ODatabaseDocumentTx.java:101)
    at com.orientechnologies.orient.core.record.ORecordAbstract.delete(ORecordAbstract.java:296)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLDelete.result(OCommandExecutorSQLDelete.java:325)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLResultsetAbstract.pushResult(OCommandExecutorSQLResultsetAbstract.java:278)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.addResult(OCommandExecutorSQLSelect.java:734)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.handleResult(OCommandExecutorSQLSelect.java:666)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.executeSearchRecord(OCommandExecutorSQLSelect.java:615)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.serialIterator(OCommandExecutorSQLSelect.java:1638)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.fetchFromTarget(OCommandExecutorSQLSelect.java:1553)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.executeSearch(OCommandExecutorSQLSelect.java:510)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLSelect.execute(OCommandExecutorSQLSelect.java:473)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLDelegate.execute(OCommandExecutorSQLDelegate.java:72)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.executeCommand(OAbstractPaginatedStorage.java:2577)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.command(OAbstractPaginatedStorage.java:2523)
    at com.orientechnologies.orient.core.sql.query.OSQLQuery.run(OSQLQuery.java:78)
    at com.orientechnologies.orient.core.sql.query.OSQLAsynchQuery.run(OSQLAsynchQuery.java:74)
    at com.orientechnologies.orient.core.query.OQueryAbstract.execute(OQueryAbstract.java:33)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLDelete.execute(OCommandExecutorSQLDelete.java:205)
    at com.orientechnologies.orient.core.sql.OCommandExecutorSQLDelegate.execute(OCommandExecutorSQLDelegate.java:72)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.executeCommand(OAbstractPaginatedStorage.java:2577)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.command(OAbstractPaginatedStorage.java:2523)
    at com.orientechnologies.orient.core.command.OCommandRequestTextAbstract.execute(OCommandRequestTextAbstract.java:69)
    at Hello$$anon$2.run(Hello.scala:752)
""Thread-6"":
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  <0x00000000d59c41a0> (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)
    at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:943)
    at com.orientechnologies.common.concur.lock.OOneEntryPerKeyLockManager.acquireLock(OOneEntryPerKeyLockManager.java:173)
    at com.orientechnologies.common.concur.lock.OOneEntryPerKeyLockManager.acquireLock(OOneEntryPerKeyLockManager.java:100)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.OAtomicOperationsManager.acquireExclusiveLockTillOperationComplete(OAtomicOperationsManager.java:464)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.OAtomicOperationsManager.startAtomicOperation(OAtomicOperationsManager.java:175)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.atomicoperations.OAtomicOperationsManager.startAtomicOperation(OAtomicOperationsManager.java:140)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.base.ODurableComponent.startAtomicOperation(ODurableComponent.java:123)
    at com.orientechnologies.orient.core.storage.impl.local.paginated.OPaginatedCluster.createRecord(OPaginatedCluster.java:441)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.doCreateRecord(OAbstractPaginatedStorage.java:3023)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.commitEntry(OAbstractPaginatedStorage.java:3584)
    at com.orientechnologies.orient.core.storage.impl.local.OAbstractPaginatedStorage.commit(OAbstractPaginatedStorage.java:1344)
    at com.orientechnologies.orient.core.tx.OTransactionOptimistic.doCommit(OTransactionOptimistic.java:555)
    at com.orientechnologies.orient.core.tx.OTransactionOptimistic.commit(OTransactionOptimistic.java:109)
    at com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx.commit(ODatabaseDocumentTx.java:2665)
    at com.orientechnologies.orient.core.db.document.ODatabaseDocumentTx.commit(ODatabaseDocumentTx.java:2634)
    at Hello$$anon$1.run(Hello.scala:728)

Found 1 deadlock.

```

Expected no deadlock.
## Steps to reproduce the problem

Run the code and wait a little (usually less than a minute)

```
      locally {
        val db = new ODatabaseDocumentTx(""plocal:databases/TestDb"")
        FileUtils.deleteDirectory(new java.io.File(""databases/TestDb""))
        db.create()
        db.close()

        db.open(""admin"", ""admin"")
        try {
          println(Try(db.command[OCommandRequest](new OCommandSQL(""CREATE CLASS Ping"")).execute[Object]()))
        } finally {
          db.close()
        }
      }

      new Thread {
        override def run {
          while(true) {
            // insert a simple record
            val db = new ODatabaseDocumentTx(""plocal:databases/TestDb"")
            db.open(""admin"", ""admin"")
            try {
              db.begin(OTransaction.TXTYPE.OPTIMISTIC)
              try {
                val d = new ODocument(""Ping"")
                d.field(""time"", System.currentTimeMillis)
                d.save()
                db.commit()
                print(GREEN+"".""+RESET)
              } catch {
                case e: Throwable =>
                  e.printStackTrace
                  db.rollback()
              }
            } finally {
              db.close()
            }
            Thread sleep 5
          }
        }
      }.start()

      new Thread {
        override def run {
          while(true) {
            // delete records older than 5 sec
            val db = new ODatabaseDocumentTx(""plocal:databases/TestDb"")
            db.open(""admin"", ""admin"")
            try {
              val now = System.currentTimeMillis
              println(s""${RED}deleting:${RESET}"")
              val rc = db .command[OCommandRequest](new OCommandSQL(""delete from Ping where time < ?"")) .execute[Int]((now - 5000).asInstanceOf[AnyRef])
              println(s""${RED}deleted old msgs ${BOLD}${rc}${RESET+RED} in ${BOLD}${System.currentTimeMillis - now}${RESET+RED} ms${RESET}"")
            } finally {
              db.close()
            }
            Thread sleep 5000
          }
        }
      }.start()
```
## Important Questions
### Runninng Mode
- [ x] Embedded, using PLOCAL access mode
- [  ] Embedded, using MEMORY access mode
- [ x] Remote

I have the issue with embedded PLOCAL, remote PLOCAL and remote MEMORY (single-server setup, no distribution). In the remote case, the deadlock occurs in the OrientDB server process.
### Misc
- [  ] I have a distributed setup with multiple servers. How many? 
- [  ] I'm using the Enterprise Edition
### OrientDB Version
- [  ] v2.0.x - Please specify last number: 
- [  ] v2.1.x - Please specify last number: 
- [x ] v2.2.x - Please specify last number: 2.2.3 community edition
### Operating System
- [  ] Linux
- [  ] MacOSX
- [ x] Windows (Windows Server 2008, Java 8)
- [  ] Other Unix
- [  ] Other, name? 
### Java Version
- [  ] 6
- [ x] 7
- [ x] 8
",https://github.com/orientechnologies/orientdb/issues/6380,1.0,0.0,0.0,39
225,"Memory leak in MimeTypeUtils LRUCache
In then current LRUCache implementation, the queue tracking recently used cached values is thread safe, at least each call to offer/add values to it is.

But in the case of highly concurrent calls for the same cached value, the current implementation can add multiple instances of the same value to the queue. Since the queue is unbounded, this can lead to memory leak issues or large queues which increases the time spent when going over the queue to find values to remove.

We'll also use this issue to improve queue lookup for recently used values by starting from the end and using a different queue implementation.",https://github.com/spring-projects/spring-framework/issues/24886,1.0,1.0,1.0,51
167,"Incorrect assertion in loading OAuth2AuthorizationRequest
`HttpSessionOAuth2AuthorizationRequestRepository.loadAuthorizationRequest()` asserts the `state` parameter as required which is incorrect. If the `state` parameter is not available in the `request` than it should simply return `null`.",https://github.com/spring-projects/spring-security/issues/5163,1.0,3.0,3.0,45
347,"Server metadata listener notification has a race condition
#### Description
Multiple threads may collect server meta data and every time they do, they notify their collection to the listeners.
When notifying the listeners, a `ServerMetaData` object is created based on everything collected up to that point and this is passed on to the listeners.
However, these 2 operations are not atomic so a thread that have created the object first could publish it later, resulting in an out of order operation.",https://github.com/naver/pinpoint/issues/2993,1.0,0.0,0.0,53
320,"Remove thread-unsafe context from the AbstractJavadocCheck class 
Now the `AbstractJavadocCheck` class contains some thread-unsafe context, therefore we cannot use the same check instance across multiple threads.

All thread-unsafe members should be rewritten so that they could be used from the separate threads:

1. `parser` - the `JavadocDetailNodeParser` isn't a thread-safe class
1. `blockCommentAst` - the `AbstractJavadocCheck` updates this field in the `visitToken` method",https://github.com/checkstyle/checkstyle/issues/4925,1.0,0.0,0.0,44
319,"Remove thread-unsafe context from the AbstractCheck class
Now the `AbstractCheck` class contains some thread-unsafe context, therefore we cannot use the same check instance across multiple threads.

All thread-unsafe members should be rewritten so that they could be used from the separate threads:

1. `messages` - it is updated via `clearMessages` and `log` methods.
1. `fileContents` - it is updated via `setFileContents` and queried via `getLine`, `getFileContents`",https://github.com/checkstyle/checkstyle/issues/4908,1.0,0.0,0.0,45
120,"ExpandCollapseSearchResponseListener potentially executes blocking calls on a network thread
We use ExpandCollapseSearchResponseListener for field collapsing but this listener executes heavy operations in a blocking fashion. This could happen on a transport thread. We should do this in an async way.

I just spoke with @jimczi how to fix it and he is taking it over. For now I will put a fix into 5.x and master since this triggers quite often due to a recent change.

Note: this code is unreleased",https://github.com/elastic/elasticsearch/issues/23048,1.0,0.0,0.0,44
375,"Subtle buffer leak
I'm running into a subtle problem, where buffer leaks are logged, but very rarely, and it appears to be entirely code within the HTTP codec, and identical requests will sometimes produce the problem and sometimes not.

[Here is a simple fileserver maven project](http://timboudreau.com/files/simple-fileserver.tar.bz2) which demonstrates it.  Try the following:
- Run it. The index page loads 10 symlinked copies of the CSS file to generate 11 requests per load.
- Load [localhost:8732/index.html](http://localhost:8732/index.html) - I used Chrome
- Click refresh in your browser many, many times, occasionally shift-reloading to get a full reload
  - The first item in each line of logging is the request number - get it up to around 1000
- Switch away from the browser and do something else for a few minutes
- Come back and refresh again.   The following is logged:
  
  ```
  1003    0.002   /0:0:0:0:0:0:0:1:41829  304 Not Modified    /default-8.css  http://localhost:8732/index.html
  Nov 08, 2013 6:17:31 PM io.netty.util.ResourceLeakDetector reportLeak
  WARNING: LEAK: ByteBuf was GC'd before being released correctly.  The following stack trace shows where the leaked object was created, rather than where you failed to release it.
  io.netty.util.ResourceLeakException: io.netty.buffer.CompositeByteBuf@2c84c504
      at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:175)
      at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:117)
      at io.netty.buffer.CompositeByteBuf.<init>(CompositeByteBuf.java:59)
      at io.netty.buffer.Unpooled.compositeBuffer(Unpooled.java:353)
      at io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:138)
      at io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:50)
      at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:89)
      at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:307)
      at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:293)
      at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:153)
      at io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:307)
      at io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:293)
      at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:775)
      at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:123)
      at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:485)
      at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452)
      at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346)
      at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:801)
      at java.lang.Thread.run(Thread.java:744)
  
  1004    0.002   /0:0:0:0:0:0:0:1:41830  304 Not Modified    /default-9.css  http://localhost:8732/index.html
  ```

This seems like some kind of interplay between whatever the default garbage collector is doing when the application is completely idle, and reference counting on buffers - but there is no information in the stack trace to diagnose what.  Any ideas?
### System info

``````
    Gentoo Linux kernel 3.10.17, i7 4-core, 8Gb RAM

```java version ""1.7.0_45""
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)```
``````
",https://github.com/netty/netty/issues/1975,1.0,1.0,1.0,51
376,"Synchronized blocks in MethodOverrides are hurting concurrency
<!--
!!! For Security Vulnerabilities, please go to https://pivotal.io/security !!!
-->
**Affects:** 5.1.x, 4.3.x

---
The fix for issue #18905 introduced `synchronized` blocks into the `MethodOverrides` class to fix a race condition. While this fixed the original bug, the introduction of the `synchronized` blocks is really hurting the concurrency of our application. We make use of method injection in a hot spot in our application, which has very high request concurrency. All of those requests go through `MethodOverrides`, and through these `synchronized` blocks. While the individual operations are fairly quick, it's still significant enough to cause serious concurrency degradation.

Can this class be reworked to avoid synchronized blocks? ",https://github.com/spring-projects/spring-framework/issues/23448,1.0,0.0,0.0,45
125,"Feature request: API to release pooled direct buffers in PooledByteBufAllocator
Right now there is no way to release pooled `DirectByteBuffer`s in `PooledByteBufAllocator`. However, Netty uses no cleaner DirectByteBuffer by default since 4.0.37. Hence, if I create a client using `PooledByteBufAllocator`, then send some messages and shutdown the client, there will be some DirectByteBuffers still in `PooledByteBufAllocator` (they are just put back into the PoolChunkList) and I don't find any way to release them, but no cleaner DirectByteBuffers require being released manually.

Running the following test will see `OutOfDirectMemoryError` quickly.

``` Java
    @Test
    public void testNoCleanerDirectByteBuffer() throws InterruptedException {
        // System.setProperty(""io.netty.maxDirectMemory"", ""0"");
        for(;;) {
            PooledByteBufAllocator allocator = new PooledByteBufAllocator(true);
            allocator.buffer(8000).release();
            allocator.freeThreadLocalCache();
        }
    }
```

Right now we just use `System.setProperty(""io.netty.maxDirectMemory"", ""0"");` to disable it to pass our thousands of unit tests.

It would be better that Netty provides an API to release them so that we can try the no cleaner DirectByteBuffers.
",https://github.com/netty/netty/issues/5833,1.0,1.0,1.0,38
301,"Race NettyResponseFuture.cancel() may produce NPE
It seems that NettyResponseFuture.cancel() is written with concurency support with CAS to prevent double execution. But assigning null to timeoutsHolder is not protected with CAS or storing it to the local. This may result in NPE. Here it the test, that may reproduce it (or may not):
```
package com.sopovs.moradanen.jcstress.asynchttpclient;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import org.asynchttpclient.DefaultAsyncHttpClient;
import org.asynchttpclient.ListenableFuture;
import org.asynchttpclient.Response;

public class RaceCancelTest {
	public static void main(String[] args) throws InterruptedException {
		try (DefaultAsyncHttpClient httpClient = new DefaultAsyncHttpClient()) {
			BlockingQueue<ListenableFuture<Response>> queue1 = new LinkedBlockingQueue<>(),
					queue2 = new LinkedBlockingQueue<>();
			Thread thread1 = new CancellingThread(queue1), thread2 = new CancellingThread(queue2);
			thread1.start();
			thread2.start();
			for (int i = 0; i < 100; i++) {
				ListenableFuture<Response> future = httpClient.prepareGet(""http://google.com"").execute();
				queue1.add(future);
				queue2.add(future);
				while(!queue1.isEmpty() || !queue2.isEmpty()){
					Thread.yield();
				}
			}
			thread1.interrupt();
			thread2.interrupt();
		}
	}

	static class CancellingThread extends Thread {
		private final BlockingQueue<ListenableFuture<Response>> queue;

		public CancellingThread(BlockingQueue<ListenableFuture<Response>> queue) {
			this.queue = queue;
		}

		@Override
		public void run() {
			while (!this.isInterrupted()) {
				try {
					ListenableFuture<Response> future = queue.take();
					future.cancel(true);
				} catch (InterruptedException e) {
					this.interrupt();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}
}
```
And here is the stacktrace:
```
java.lang.NullPointerException
	at org.asynchttpclient.netty.NettyResponseFuture.cancelTimeouts(NettyResponseFuture.java:286)
	at org.asynchttpclient.netty.NettyResponseFuture.cancel(NettyResponseFuture.java:143)
	at com.sopovs.moradanen.jcstress.asynchttpclient.RaceCancelTest$CancellingThread.run(RaceCancelTest.java:44)
```",https://github.com/AsyncHttpClient/async-http-client/issues/1365,1.0,0.0,0.0,36
402,"UniqueId.parse fails for methods with array type parameters
## Bug description
```
String idString = uniqueIdFromMethodDescriptorWithArrayParameter.toString();
UniqueId id = UniqueId.parse(idString);
```
will fail with `PreconditionViolation` since array types are described with an `[` in front but `[` chars are currently forbidden as segment values.

## Suggested Solution

Change representation of array types in `ReflectionUtils.findMethod(clazz, methodName, parameterTypeNames)` and `StringUtils.nullSafeToString(classes)`. 

Alternative: Don't use `[` as separator char in unique IDs. But some 3rd party tools might already have committed to the current format.

## Deliverables

- [ ] Encode `segmentType` and `value` in constructor and decode in `parse`.",https://github.com/junit-team/junit5/issues/810,1.0,3.0,3.0,40
299,"RLocalCachedMap memory leak when using EvictionPolicy.WEAK
﻿### Expected behavior
Weak references should be cleared.

### Actual behavior
It seems that even when using static Strings for keys and values and only ```fastPut``` method the OOM error occurs after several thousands of invocations.
  
### Steps to reproduce or test case
I have created a separate repo to easier reproduce the problem:
https://github.com/pawelgrzes/redisson-mem-leak

### Redis version
4.0.9

### Redisson version
3.7.0

### Redisson configuration
```
RedissonClient redissonClient = Redisson.create();

LocalCachedMapOptions ops = LocalCachedMapOptions.defaults()
  .cacheSize(0)
  .timeToLive(0)
  .maxIdle(0)
  .reconnectionStrategy(LocalCachedMapOptions.ReconnectionStrategy.CLEAR)
  .syncStrategy(LocalCachedMapOptions.SyncStrategy.INVALIDATE)
  .evictionPolicy(LocalCachedMapOptions.EvictionPolicy.WEAK);

RLocalCachedMap<String, String> map = redissonClient.getLocalCachedMap(""sample-cache"", ops);
```

",https://github.com/redisson/redisson/issues/1442,1.0,1.0,1.0,48
71,"Configure Eclipse plugin to include JOpt Simple in generated .classpath file
## Status Quo

Due to the changes introduced in #309, executing `gradle cleanEclipse eclipse` no longer results in a generated `.classpath` file that includes the JOpt Simple dependency. Consequently, it is impossible to build the `junit-platform-console` module within Eclipse when using this mechanism.

## Deliverables

- [x] Modify `junit-platform-console.gradle` so that the JOpt Simple dependency is once again included in the generated `.classpath` file for Eclipse.",https://github.com/junit-team/junit5/issues/556,1.0,2.0,2.0,49
178,"InternalThreadLocalMap recent change is causing increased GCs
### Expected behavior
InternalThreadLocalMap.stringBuilder() method is returning thread local java.lang.StringBuilder() object without causing too much of GC overhead. Implementation before 4.1.13 had thread-local large builders, that basically were always reused, in most cases without being collected. I would expect the 1024 limit that is currently on the stringBuilder could be bigger, as 1K for Cookie headers is nothing special.

### Actual behavior
After changes in netty 4.1.14 how StringBuilder object is being trimmed, if you operate with headers ~1Kb, the method will create a new big char[] array on every request, due to how StringBuilder.trimToSize() is implemented, which in case of HotSpot at least is causing big (20% in our case) increase of minor GCs and huge outside of TLAB memory allocation, which doesn't have any added value.

### Steps to reproduce
Execute heavy performance tests with requests that will have  ~2K Cookie header with a setup that will also do some io.netty.handler.codec.http.cookie.ClientCookieEncoder.encode(Cookie[]) execution.

### Netty version
4.1.14
### JVM version (e.g. `java -version`)
jdk1.8.0_45

",https://github.com/netty/netty/issues/7092,1.0,1.0,1.0,43
156,"HttpContentEncoder leaks resources
17:47:24,585  WARN ResourceLeakDetector:151    - LEAK: ByteBuf was GC'd before being released correctly.
io.netty.util.ResourceLeakException: io.netty.buffer.PooledHeapByteBuf@6dde8fae
    at io.netty.util.ResourceLeakDetector$DefaultResourceLeak.<init>(ResourceLeakDetector.java:158)
    at io.netty.util.ResourceLeakDetector.open(ResourceLeakDetector.java:103)
    at io.netty.buffer.PooledByteBuf.<init>(PooledByteBuf.java:42)
    at io.netty.buffer.PooledHeapByteBuf.<init>(PooledHeapByteBuf.java:44)
    at io.netty.buffer.PooledHeapByteBuf.<init>(PooledHeapByteBuf.java:28)
    at io.netty.buffer.PooledHeapByteBuf$1.newObject(PooledHeapByteBuf.java:33)
    at io.netty.buffer.PooledHeapByteBuf$1.newObject(PooledHeapByteBuf.java:30)
    at io.netty.util.Recycler.get(Recycler.java:40)
    at io.netty.buffer.PooledHeapByteBuf.newInstance(PooledHeapByteBuf.java:38)
    at io.netty.buffer.PoolArena$HeapArena.newByteBuf(PoolArena.java:357)
    at io.netty.buffer.PoolArena.allocate(PoolArena.java:93)
    at io.netty.buffer.PooledByteBufAllocator.newHeapBuffer(PooledByteBufAllocator.java:222)
    at io.netty.buffer.AbstractByteBufAllocator.heapBuffer(AbstractByteBufAllocator.java:111)
    at io.netty.buffer.AbstractByteBufAllocator.heapBuffer(AbstractByteBufAllocator.java:97)
    at io.netty.handler.codec.MessageToByteEncoder.write(MessageToByteEncoder.java:96)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite0(DefaultChannelHandlerContext.java:719)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite(DefaultChannelHandlerContext.java:703)
    at io.netty.channel.DefaultChannelHandlerContext.write(DefaultChannelHandlerContext.java:697)
    at io.netty.channel.DefaultChannelHandlerContext.write(DefaultChannelHandlerContext.java:480)
    at io.netty.channel.DefaultChannelPipeline.write(DefaultChannelPipeline.java:842)
    at io.netty.channel.AbstractChannel.write(AbstractChannel.java:251)
    at io.netty.channel.embedded.EmbeddedChannel.writeOutbound(EmbeddedChannel.java:169)
    at io.netty.handler.codec.http.HttpContentEncoder.encode(HttpContentEncoder.java:265)
    at io.netty.handler.codec.http.HttpContentEncoder.encodeContent(HttpContentEncoder.java:205)
    at io.netty.handler.codec.http.HttpContentEncoder.encode(HttpContentEncoder.java:166)
    at io.netty.handler.codec.http.HttpContentEncoder.encode(HttpContentEncoder.java:54)
    at io.netty.handler.codec.MessageToMessageCodec$1.encode(MessageToMessageCodec.java:66)
    at io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:80)
    at io.netty.handler.codec.MessageToMessageCodec.write(MessageToMessageCodec.java:105)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite0(DefaultChannelHandlerContext.java:719)
    at io.netty.channel.DefaultChannelHandlerContext.invokeWrite(DefaultChannelHandlerContext.java:703)
    at io.netty.channel.DefaultChannelHandlerContext.write(DefaultChannelHandlerContext.java:697)
    at io.netty.channel.DefaultChannelHandlerContext.write(DefaultChannelHandlerContext.java:687)
    at io.netty.channel.DefaultChannelHandlerContext.write(DefaultChannelHandlerContext.java:475)
",https://github.com/netty/netty/issues/1524,1.0,1.0,1.0,43
408,"Update to spring-build-conventions:0.0.13.RELEASE
### Summary
Update to spring-build-conventions:0.0.13.RELEASE",https://github.com/spring-projects/spring-security/issues/5030,1.0,2.0,2.0,35
295,"Problems with 5.0 snapshots' poms
### Summary

The poms for the latest 5.0 snapshots have a few problems:

- They do not include any optional dependencies
- They include test dependencies
- They import platform-bom in their dependency management
- `commons-logging` is a required dependency

### Actual Behavior

N/A

### Expected Behavior

The poms for 5.0.0 snapshots are similar to those for 4.2.2 in that they have none of the 4 problems described above.

### Configuration

N/A

### Version

5.0.0.BUILD-SNAPSHOT, specifically 5.0.0.BUILD-20170424.000033-75

### Sample

N/A",https://github.com/spring-projects/spring-security/issues/4308,1.0,2.0,2.0,53
292,"Potential resource leak in SslHandler
`SslHandler.closeOutboundAndChannel(...)`, does not send the specified event downstream at all if `SslEngine.isInboundDone()` returns `true`.  If a user relies on the future of the specified event, the user will never be notified.  Also, if the peer does not close the connection after sending `close_notify`, the connection will never be closed, although all well-behaving peers will do.

This issue was introduced by beadadecf7489dbcc43d7939f796cc4017340a49.
",https://github.com/netty/netty/issues/1116,1.0,1.0,1.0,49
230,"Memory leaks when using concatMap and subscribeOn Schedulers.newSingle
When running the following test:
```
@Test
    public void test() throws Exception {
        AtomicLong counter = new AtomicLong(0L);
        Scheduler scheduler = Schedulers.newParallel(""scheduler"", 10);
        Flux
            .<Long>generate(sink -> sink.next(counter.getAndIncrement()))
            .concatMap(i -> {
                return Mono.just(i)
                    .publishOn(scheduler)
                    .map(number -> number * 2L);
            })
            .subscribeOn(Schedulers.newSingle(""subscriber""))
            .subscribe(new BaseSubscriber<Long>() {
                @Override
                protected void hookOnSubscribe(Subscription subscription) {
                    subscription.request(10);
                }

                @Override
                protected void hookOnNext(Long value) {
                    upstream().request(1);
                }
            });

        Thread.sleep(100000000);
    }
```
Memory starts to leak.
Thanks to @dfeist the leak seems to be here `reactor.core.scheduler.SingleScheduler.SingleWorker#tasks` and as a workaround scheduler can be replaced with
`.subscribeOn(Schedulers.fromExecutorService(Executors.newSingleThreadExecutor()))`.",https://github.com/reactor/reactor-core/issues/578,1.0,1.0,1.0,40
155,"HonoConnection.shutdown() blocks for 5s if called on event loop thread
`HonoConnection.shutdown()` blocks the current thread for 5s waiting for the close frame from the remote peer.
If the current thread is the thread of the vertx context that the HonoConnection operates on, the response from the remote peer can't be processed while the thread is blocked, causing for the 5s timeout to occur.

Same applies to the `disconnect` method.",https://github.com/eclipse/hono/issues/1750,1.0,0.0,0.0,47
413,"Users guide shows end::how-does-it-work[]
You should not be able to see the tag in the [doc](http://docs.spring.io/spring-session/docs/1.0.0.RELEASE/reference/html5/guides/users.html#automatic-session-alias-inclusion-with-encodeurl)

```
end::how-does-it-work[]
```
",https://github.com/spring-projects/spring-session/issues/145,1.0,2.0,2.0,45
291,"Potential direct memory leak in HttpContentEn/Decoder
If `HttpContentEncoder` or `HttpContentDecoder` encodes or decodes a new `HttpMessage` before handling the previous message's last chunk, zlib's native memory is not freed, causing direct memory leak.
",https://github.com/netty/netty/issues/539,1.0,1.0,1.0,52
207,"Locale inconsistently resolves to null for invalid input value
<!--
!!! For Security Vulnerabilities, please go to https://pivotal.io/security !!!
-->
**Affects:** 5.1.5.RELEASE

---

I am trying to receive a `Locale` into a required `@RequestParam`. The happy path parsing works great, but I am receiving `null` into my `@RequestMapping` when `Locale` parsing fails. Here's my currently-failing test (run against Spring Boot 2.1.3.RELEASE):

```java
@WebMvcTest
public class LocaleDeserializationTest {

    @Configuration
    static class Config {

        @RestController
        static class LocaleController {

            @GetMapping(""/request-param"")
            public String requestParam(@RequestParam Locale locale) {
                return locale.toLanguageTag();
            }
        }
    }

    @Autowired
    MockMvc mockMvc;

    @Test
    public void badLocaleRequestParam() throws Exception {
        mockMvc.perform(get(""/request-param"").param(""locale"", ""thiswillbebadrequest""))
                .andExpect(status().isBadRequest());
    }
}
```

This in fact throws a `NullPointerException` because `locale` is null within the execution of the `requestParam()` method. I also tried marking the argument as `@NonNull` (the Spring variant) but that also still allowed `null` to come in for `Locale`.

A bit of investigation led me to the `StringToLocaleConverter`, and `StringUtils.parseLocale()` correctly returns null. I would expect that since my `@RequestParam` is a _required_ parameter, this would end up returning a 400 client response.

The same thing happens with `@PathVariable`, but I would expect that one would actually be a 404 not found.",https://github.com/spring-projects/spring-framework/issues/22603,1.0,3.0,3.0,44
154,"High heap usage on get field mapping API
Environment:
- 62 indices
- 50+ types
- Java 7.0_67
- JVM arguments `-Xms8G -Xmx8G`
- Elasticsearch version 1.7.5 (branch 1.7)

Steps:
1. Start Elasticsearch
2. Execute the following query `http://localhost:9200/logstash/_mapping/field/*` (produced by Kibana)
3. Wait the response
4. Run the same query again

Here is the result (screenshot from JVisualVM);
![mapping-memory-leak-confirmed](https://cloud.githubusercontent.com/assets/333276/12142867/b68a64c0-b47b-11e5-9f04-5fefbe9b6754.JPG)

As you can see the first execution of the query took about 1G of memory and the second execution of the query took about 2.5G (more than 2 times more memory than the first execution).
I tried to force GC but no memory is free up.

Using MAT, I can see that the memory is filled with `FieldMappingMetaData`.
I'm not sure if this is intended but I `GetFieldMappingsResponse` keeps a reference of the mapping: https://github.com/elastic/elasticsearch/blob/1.7/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsResponse.java#L39

I didn't try on Elasticsearch 2.x but the code is more or less the same.
",https://github.com/elastic/elasticsearch/issues/15789,1.0,1.0,1.0,48
157,"IMA Extension Memory Leak
### Issue description
Using IMA Extension and in the sample main demo app, a memory leak happens when you serve a VMAP and quit the player activity during content playback and after ad/pods playback.

In my opinion, it's an IMA problem and managed to reproduce the issue even without an IMA Extension and following exactly their integration guide but according to them they're claiming it's an IMA-Extension problem and not theirs
https://groups.google.com/forum/#!topic/ima-sdk/ZM-WsPL1xdQ


### Reproduction steps
- In the Main Demo app, use any video and set the following sample adtag uri:
https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostlongpod&cmsid=496&vid=short_tencue&correlator=
- When pre-roll finishes and content video plays for few seconds, press back to return to the home screen, PlayerActivity gets leaked


### Link to test content
Provide a link to media that reproduces the issue. If you don't wish to post it
publicly, please submit the issue, then email the link to
dev.exoplayer@gmail.com using a subject in the format ""Issue #1234"".


### Version of ExoPlayer being used
V2.7.3


### Device(s) and version(s) of Android being used
Tested on Pixel XL (Oreo 8.1), Xperia XZ (Oreo 8.0) but can be reproduced on any device",https://github.com/google/ExoPlayer/issues/4114,1.0,1.0,1.0,46
33,"Build system does not support HTTPS calls to Maven
**Describe the bug**
When I try to run `./refine build`, I get a 501 error when the build system attempts to contact `http://repo.maven.apache.org/`.  This appears to be related to Maven's HTTPS switchover on 2020-01-15 (https://blog.sonatype.com/central-repository-moving-to-https), which causes `http://` calls to be rejected.

**To Reproduce**
Steps to reproduce the behavior:
1. Clone the master repository
2. `./refine build`

**Current Results**
```[INFO] ------------------------------------------------------------------------
[INFO] Building OpenRefine 3.3-SNAPSHOT
[INFO] ------------------------------------------------------------------------
Downloading: http://repo.maven.apache.org/maven2/org/codehaus/mojo/build-helper-maven-plugin/1.8/build-helper-maven-plugin-1.8.pom
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] OpenRefine ......................................... FAILURE [  3.014 s]
[INFO] OpenRefine - main .................................. SKIPPED
[INFO] OpenRefine - server ................................ SKIPPED
[INFO] OpenRefine - extensions ............................ SKIPPED
[INFO] OpenRefine - Jython extension ...................... SKIPPED
[INFO] OpenRefine - Wikidata extension .................... SKIPPED
[INFO] OpenRefine - Database extension .................... SKIPPED
[INFO] OpenRefine - Gdata extension ....................... SKIPPED
[INFO] OpenRefine - PC-axis extension ..................... SKIPPED
[INFO] OpenRefine - Phonetic clustering extension ......... SKIPPED
[INFO] OpenRefine - packaging ............................. SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.927 s
[INFO] Finished at: 2020-01-15T12:02:00-05:00
[INFO] Final Memory: 7M/37M
[INFO] ------------------------------------------------------------------------
[ERROR] Plugin org.codehaus.mojo:build-helper-maven-plugin:1.8 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.codehaus.mojo:build-helper-maven-plugin:jar:1.8: Could not transfer artifact org.codehaus.mojo:build-helper-maven-plugin:pom:1.8 from/to central (http://repo.maven.apache.org/maven2): Failed to transfer file: http://repo.maven.apache.org/maven2/org/codehaus/mojo/build-helper-maven-plugin/1.8/build-helper-maven-plugin-1.8.pom. Return code is: 501 , ReasonPhrase:HTTPS Required. -> [Help 1]
```

**Expected behavior**
The build system is able to successfully contact the Maven repository and download necessary files.

**Desktop (please complete the following information):**
 - OS: macOS 10.14.6
 - Browser Version: n/a
 - JRE or JDK Version: openjdk 12.0.1 2019-04-16

**OpenRefine (please complete the following information):**
 - Version: 3.3-SNAPSHOT
",https://github.com/OpenRefine/OpenRefine/issues/2286,1.0,2.0,2.0,53
69,"ConcurrentModificationException while making notification
Hi,
i'm geting exception when running below code:

<pre><code>public static void makeMutableWorkoutCopy(Realm realm, final long workoutId) {
        realm.beginTransaction();
            Workout workout = realm.where(Workout.class).equalTo(""id"", workoutId).findFirst();

            Workout copyWorkout = realm.copyFromRealm(workout);
            copyWorkout.setId(IdentifierGenerator.getInstance().generateUniqueId(realm, Workout.class));
            copyWorkout.setName(copyWorkout.getName() + ""*"");
            copyWorkout.setSections(new RealmList<Section>());
            copyWorkout.setImmutableWorkout(workout);

            workout.setMutableWorkout(realm.copyToRealmOrUpdate(copyWorkout));
        realm.commitTransaction();
    }</code></pre>

Exception:

<pre><code>java.util.ConcurrentModificationException
at java.util.IdentityHashMap$IdentityHashMapIterator.checkConcurrentMod(IdentityHashMap.java:164)
at java.util.IdentityHashMap$IdentityHashMapIterator.next(IdentityHashMap.java:169)
at io.realm.HandlerController.notifyRealmObjectCallbacks(HandlerController.java:254)
at io.realm.HandlerController.notifyTypeBasedListeners(HandlerController.java:207)
at io.realm.BaseRealm.commitTransaction(BaseRealm.java:294)
at io.realm.Realm.commitTransaction(Realm.java:108)
at com.borg.forza.model.RealmUtils.makeMutableWorkoutCopy(RealmUtils.java:289)
</code></pre>


The model of Workout.class looks like below:

<pre><code>public class Workout extends RealmObject {

    @Index      private long                    id;
                private long                    backendId;
                private int                     sync;

    @PrimaryKey private String                  name;
                private String                  description;
    @Index      private String                  type;
                private long                    duration;
                private RealmList<Section>      sections;
                private int                     access;
                private Workout                 mutableWorkout;
                private Workout                 immutableWorkout;
    }</code></pre>

I am using 0.87.0-SNAPSHOT.
Thanks!
",https://github.com/realm/realm-java/issues/1970,1.0,0.0,0.0,40
100,"Documentation typo fixes
<!--
For Security Vulnerabilities, please use https://pivotal.io/security#reporting
-->

### Summary
Backport #5205",https://github.com/spring-projects/spring-security/issues/5317,1.0,2.0,2.0,34
310,"Redis Buffer Leak
RedisDecoder calls `ByteBuf.retain()` and the next line may throw an exception, but the buffer is never released [1]. More investigation is needed in this class whenever retain is called to ensure it is either written or released.

[1] https://github.com/netty/netty/blob/4.1/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java#L208
",https://github.com/netty/netty/issues/5190,1.0,1.0,1.0,42
67,"ConcurrentModificationException when flushing projects at shutdown
User Ryan Elenbaum reported this exception when shutting down the Refine server

java.util.ConcurrentModificationException
        at java.util.HashMap$HashIterator.nextEntry(HashMap.java:894)
        at java.util.HashMap$EntryIterator.next(HashMap.java:934)
        at java.util.HashMap$EntryIterator.next(HashMap.java:932)
        at com.google.refine.InterProjectModel.flushJoinsInvolvingProject(InterProjectModel.java:109)
        at com.google.refine.model.Project.dispose(Project.java:109)
        at com.google.refine.ProjectManager.saveProjects(ProjectManager.java:265) 
        at com.google.refine.ProjectManager.save(ProjectManager.java:206)
        at com.google.refine.ProjectManager.dispose(ProjectManager.java:99)
        at com.google.refine.RefineServlet.destroy(RefineServlet.java:151)
        at org.mortbay.jetty.servlet.ServletHolder.destroyInstance(ServletHolder.java:318)
        at org.mortbay.jetty.servlet.ServletHolder.doStop(ServletHolder.java:289)
        at org.mortbay.component.AbstractLifeCycle.stop(AbstractLifeCycle.java:76)
",https://github.com/OpenRefine/OpenRefine/issues/652,1.0,0.0,0.0,45
380,"Target is unresolvable
The Oxygen target cannot be resolved. In the site http://download.eclipse.org/releases/oxygen/, there are three errors:

Unable to locate installable unit org.eclipse.ecf.remoteservice.rest.synd.feature.feature.group 0.0.0
Unable to locate installable unit org.eclipse.ecf.remoteservice.sdk.source.feature.feature.group 0.0.0
Unable to locate installable unit org.eclipse.ecf.remoteservice.soap.feature.feature.group 0.0.0

On the mailing list, nobody could justify why these features are in the target and removing them seems to get the target and build working again, so I assume that whatever was in them has been moved to other features in Oxygen and suggest their removal.",https://github.com/eclipse/ice/issues/373,1.0,2.0,2.0,42
307,"ReadableBuffers.BufferInputStream does not release buffer on close()
**gRPC Version used: 1.7.0
Netty Version used: 4.1.16.Final
Java version: 1.8.0_161**

Context:
Observed Netty leak detector complaining of bytebuf leaks on the gRPC server configured with Netty Epoll. This occurs more often, a few minutes after the service restarts on a prod machine. Here is the full trace of all 25 access for the bytebuf:
 [netty_buf_leak_trace.txt](https://github.com/grpc/grpc-java/files/1795622/netty_buf_leak_trace.txt)

The most recent access to the leaked bytebuf occurs at `io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:273)` but the bytebuf is actually released here.  Not sure what is causing the leak.

```
 ERROR [2018-03-09 02:25:49,034] io.netty.util.ResourceLeakDetector: LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
 Recent access records: 25
 #25:
 	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:273)
 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
 	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
 	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1359)
 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
 	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
 	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:935)
 	io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:797)
 	io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:404)
 	io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:304)
 	io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858)
 	io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:138)
 	java.lang.Thread.run(Thread.java:748)
```





",https://github.com/grpc/grpc-java/issues/4198,1.0,1.0,1.0,48
232,"MessageChannelMetricWriter and @ExportMetricWriter
The `MessageChannelMetricWriter` `@Bean` in the `MetricsChannelAutoConfiguration` must be marked with the `@ExportMetricWriter`, otherwise it is skipped by the `MetricExportAutoConfiguration`:

``` java
@Autowired(required = false)
@ExportMetricWriter
private Map<String, GaugeWriter> writers = Collections.emptyMap();
```

After declaring the former in my own config:

``` java
@Bean
public MessageChannel metricsChannel() {
    return new DirectChannel();
}

@Bean
@ExportMetricWriter
public MessageChannelMetricWriter messageChannelMetricWriter() {
    return new MessageChannelMetricWriter(metricsChannel());
}

@Bean
@ServiceActivator(inputChannel = ""metricsChannel"")
public MessageHandler metricsHandler() {
    return System.out::println;
}
```

The metrics are started to appear in the STDOUT periodically as it is declared by the `MetricExportProperties`.

Also see http://stackoverflow.com/questions/36272482/write-out-spring-boot-metrics-to-stdout-or-aggregator.
",https://github.com/spring-projects/spring-boot/issues/5517,1.0,3.0,3.0,48
40,"Cannot access `package-list` in published Javadoc
## Bug Report for JUnit 4

`javadoc -link http://junit.org/junit4/javadoc/latest` (i.e. referring JUnit 4's Javadoc pages from 3rd-party Javadoc pages) no longer works because http://junit.org/junit4/javadoc/latest/package-list disappeared.

### Deliverables

- [x] See https://github.com/junit-team/junit5/issues/1289#issuecomment-364247470

## Bug Report for JUnit 5

An upgrade in the JDK used to generate Javadoc for JUnit 5 caused the `package-list` file to stop being published beginning with JUnit 5.2.

In the following list, the first number is the HTTP response code.

- *200*: https://junit.org/junit5/docs/5.1.0/api/package-list
- *404*: https://junit.org/junit5/docs/5.2.0/api/package-list
- *404*: https://junit.org/junit5/docs/current/api/package-list

### Deliverables

- [x] Manually copy `element-list` to `package-list` for previously released versions of JUnit 5.
- [x] Automate copying of `element-list` to `package-list` in the Gradle build for future versions of JUnit 5.
",https://github.com/junit-team/junit5/issues/1289,1.0,2.0,2.0,54
218,"Member / Client OOME GC overhead limit, create-use-distributed-obj-destroy

/disk1/jenkins/workspace/shutdown-All/3.10-SNAPSHOT/2018_03_20-18_17_05/stable/destroy/create-use-dist-destroy Failed

```
fail HzClient1HZ _create-use-dist-destroy_createUseDistDestroy_id hzcmd.id.generator.CreateUse threadId=0 java.lang.Exception: java.lang.OutOfMemoryError: GC overhead limit exceeded 
```

http://54.82.84.143/~jenkins/workspace/shutdown-All/3.10-SNAPSHOT/2018_03_20-18_17_05/stable/destroy/create-use-dist-destroy

GC
http://54.82.84.143/~jenkins/workspace/shutdown-All/3.10-SNAPSHOT/2018_03_20-18_17_05/stable/destroy/create-use-dist-destroy/gc.html

```
output/HZ/HzMember4HZ/HzMember4HZ.hprof
output/HZ/HzClient2HZ/exception.txt
output/HZ/HzClient2HZ/HzClient2HZ.hprof
output/HZ/HzClient1HZ/exception.txt
output/HZ/HzClient1HZ/HzClient1HZ.oome
output/HZ/HzClient1HZ/HzClient1HZ.hprof
```

http://54.82.84.143/~jenkins/workspace/shutdown-All/3.10-SNAPSHOT/2018_03_20-18_17_05/stable/destroy/create-use-dist-destroy/output/HZ/HzMember4HZ/

http://54.82.84.143/~jenkins/workspace/shutdown-All/3.10-SNAPSHOT/2018_03_20-18_17_05/stable/destroy/create-use-dist-destroy/output/HZ/HzClient1HZ/",https://github.com/hazelcast/hazelcast/issues/12679,1.0,1.0,1.0,41
418,"War deployment in standalone Tomcat causes webclassloader memory leak
During startup Spring Boot invokes `SLF4JBridgeHandler.install()` to add a logging handler to container's LogManager, but during application shutdown (undeploy) adequate `SLF4JBridgeHandler.uninstall()` or `SLF4JBridgeHandler.removeHandlersForRootLogger()` is not called. I think it should be.

The bug manifests itself in taking metaspace memory space and following message is displayed after invoking Tomcat's find leaks method:
Message:    

```
The following web applications were stopped (reloaded, undeployed), but their
classes from previous runs are still loaded in memory, thus causing a memory
leak (use a profiler to confirm):
/spring-boot-logging-issue
```

Below is my workaround that solves the issue. It removes the logging handler during ContextClosedEvent.

```
@Bean
public ApplicationListener<ContextClosedEvent> uninstallSLF4JBridgeHandlerWorkaround() {
    return new ApplicationListener<ContextClosedEvent>() {
        @Override
        public void onApplicationEvent(ContextClosedEvent event) {
            try {
                SLF4JBridgeHandler.removeHandlersForRootLogger();
            } catch (NoSuchMethodError ex) {
                SLF4JBridgeHandler.uninstall();
            }
        }
    };
}
```

Tested with Tomcat 8.0.15 and OpenJDK 1.8.0_25 on Linux 3.17.6
",https://github.com/spring-projects/spring-boot/issues/2324,1.0,1.0,1.0,35
385,"This DirectMemory should be released
I faced the huge direct memory usage in my application (using Netty). I research it and found this ReadOnlyByteBufferBuf copy method.


https://github.com/netty/netty/blob/eb7f751ba519cbcab47d640cd18757f09d077b55/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java#L419


It seams to create DirectByteBuffer and put it to UnpooledDirectByteBuf constructor. In this constructor, 'doNotFree field' will set to true. Then this DirectByteBuffer seams be not freed (by code. But GC will free this memory).


I hope Netty free this memory.",https://github.com/netty/netty/issues/7103,1.0,1.0,1.0,51
36,"ByteBuf leak in NioDatagramChannel when IOException occure
Using Netty 4.0.21.Final.

While debuging my code in paranoid mode, a temporary problem on my DNS leads to IOException. Then the leak detector triggers that the ByteBuf allocated in io.netty.channel.socket.nio.NioDatagramChannel.doWriteMessage(NioDatagramChannel.java:298) was not released before being GC.

While looking at the code, it seems obvious than if an exception is triggered during the call of DatagramChannel.send() or write(), the ByteBuf allocated when needsCopy var is true will be lost.

This problem was resolved in 4.1 branch while solving issue #2239.
",https://github.com/netty/netty/issues/2644,1.0,1.0,1.0,44
127,"File#mkdirs gets stuck, might be concurrency issue
In 0.16, only create it under a global mutex lock. In 0.17, lets try and be smarted and detect that its stuck....
",https://github.com/elastic/elasticsearch/issues/1147,1.0,0.0,0.0,48
391,"Tomcat sometimes warns about threads that have not been stopped when app is shut down using the shutdown endpoint
```
2016-07-08 13:51:15.363  WARN 22433 --- [ost-startStop-2] o.a.c.loader.WebappClassLoaderBase       : The web application [ROOT] appears to have started a thread named [Thread-8] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 sun.misc.Unsafe.park(Native Method)
 java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
 java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
 java.util.concurrent.FutureTask.get(FutureTask.java:191)
 org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:972)
 org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:224)
 org.apache.catalina.core.StandardService.stopInternal(StandardService.java:502)
 org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:224)
 org.apache.catalina.core.StandardServer.stopInternal(StandardServer.java:808)
 org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:224)
 org.apache.catalina.startup.Tomcat.stop(Tomcat.java:356)
 org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer.stop(TomcatEmbeddedServletContainer.java:236)
 org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.stopAndReleaseEmbeddedServletContainer(EmbeddedWebApplicationContext.java:302)
 org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.onClose(EmbeddedWebApplicationContext.java:151)
 org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:988)
 org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:934)
 org.springframework.boot.actuate.endpoint.ShutdownEndpoint$1.run(ShutdownEndpoint.java:70)
 java.lang.Thread.run(Thread.java:745)
2016-07-08 13:51:15.363  WARN 22433 --- [ost-startStop-2] o.a.c.loader.WebappClassLoaderBase       : The web application [ROOT] appears to have started a thread named [Tomcat-startStop-2] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:
 sun.misc.Unsafe.park(Native Method)
 java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
 java.util.concurrent.FutureTask.awaitDone(FutureTask.java:429)
 java.util.concurrent.FutureTask.get(FutureTask.java:191)
 org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:972)
 org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:224)
 org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1424)
 org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1413)
 java.util.concurrent.FutureTask.run(FutureTask.java:266)
 java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
 java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
 java.lang.Thread.run(Thread.java:745)
```
",https://github.com/spring-projects/spring-boot/issues/6361,1.0,0.0,0.0,42
392,"Transpiling of `for (let x of ...)` doesn't transpile `let`.
In the following example `let str` doesn't get renamed. In `for (let str;;)` it's renamed as it should be.

``` javascript
var str = 'hi';

for (let str of [1, 2, 3]) {
  alert(str);
}

alert(str);
```

https://closure-compiler-debugger.appspot.com/#input0%3Dvar%2520str%2520%253D%2520'hi'%253B%250A%250Afor%2520(let%2520str%2520of%2520%255B1%252C%25202%252C%25203%255D)%2520%257B%250A%2520%2520alert(str)%253B%250A%257D%250A%250Aalert(str)%253B%250A%26input1%26conformanceConfig%26externs%26refasterjs-template%26includeDefaultExterns%3D1%26CHECK_SYMBOLS%3D1%26CHECK_TYPES%3D1%26LANG_IN_IS_ES6%3D1%26MISSING_PROPERTIES%3D1%26PRETTY_PRINT%3D1%26TRANSPILE%3D1
",https://github.com/google/closure-compiler/issues/717,1.0,3.0,3.0,39
393,"Trying to catch a dead lock
Hi there,

I'm trying to locate a dead-lock which is happening somewhere inside Realm.
By logging I found that I get an infinite ANR in `onCreate()` of the MainActivity on the line `Realm.getDefaultInstance()`. Another place where it hangs is a worker thread on the line `Realm.close()`.

Here is how the worker thread body looks like (without the domain details):

``` java
Realm realm = null;
try {
    realm = Realm.getDefaultInstance();
    RealmResults<A> results = realm.where(A.class).findAll();
    realm.beginTransaction();
    for (int i = results.size() - 1; i >= 0; i--) {
        final A item = results.get(i);
        String value = item.getSomeStringValue();
        callSomeMethod(value); // this method throws an exception not related to realm when i == 1
    }
    realm.commitTransaction();
} finally {
    if (realm != null) {
        realm.close(); // hangs on this line based on the logs
    }
}
```

I was able to narrow down where exactly Realm.close() hangs. It is the line `synchronized (BaseRealm.class)`:

``` java
protected void lastLocalInstanceClosed() {
        // validatedRealmFiles must not modified while other thread is executing createAndValidate()
        synchronized (BaseRealm.class) {
            validatedRealmFiles.remove(configuration.getPath());
        }
        realmsCache.get().remove(configuration);
    }
}
```

Here is the sequence of actions accordingly to logs:
1. Application.onCreate() called and starts the worker thread
2. Worker thread is going through the items
3. MainActivity.onCreate() called and it hangs on Realm.getDefaultInstance()
4. Exception thrown in the worker thread, and it hangs on realm.close()
5. Infinite ANR in MainActivity

It's very hard to locate the problem because it's not 100% reproducible and time-dependent. If I remove transaction, or there is no exception then the dead-lock doesn't happen (could be just due to timing). Also, I have another running worker thread in background which uses realm. But it successfully finishes and doesn't hang on `realm.close()`. 

I tried to reproduce it in a small project, but it didn't work out.

I hope this description could lead you to some ideas what could go wrong, or what I can check to locate the exact problem.
",https://github.com/realm/realm-java/issues/1728,1.0,0.0,0.0,39
99,"Documentation incorrect - reference/2.0/modules-scripting.html
https://www.elastic.co/guide/en/elasticsearch/reference/2.0/modules-scripting.html

Documentation example below causes ""script_score query does not support [file]"" error

```
     ""script_score"": {
        ""lang"": ""groovy"",
        ""file"": ""calculate-score"",
        ""params"": {
          ""my_modifier"": 8
        }
      }
```

Should be 

""script_file"": ""calculate-score""
",https://github.com/elastic/elasticsearch/issues/15096,1.0,2.0,2.0,41
304,"Race in PoolArena.allocate
It appears there might be a race in `io.netty.buffer.PoolArena.allocate`, where `allocationsTiny` is incremented.  While the value is incremented under a lock, it also appears to be mutated elsewhere in the file without a lock.  A race detector suggested the two places where the class accesses this field in an unsynchronized way:

```
  Read of size 8 at 0x7f2f7be16108 by thread T53 (mutexes: write M95278):
    #0 io.netty.buffer.PoolArena.allocate(Lio/netty/buffer/PoolThreadCache;Lio/netty/buffer/PooledByteBuf;I)V (PoolArena.java:198)  
    #1 io.netty.buffer.PoolArena.reallocate(Lio/netty/buffer/PooledByteBuf;IZ)V (PoolArena.java:359)  
    #2 io.netty.buffer.PooledByteBuf.capacity(I)Lio/netty/buffer/ByteBuf; (PooledByteBuf.java:120)  
    #3 io.netty.buffer.AbstractByteBuf.ensureWritable0(I)V (AbstractByteBuf.java:269)  
    #4 io.netty.buffer.AbstractByteBuf.ensureWritable(I)Lio/netty/buffer/ByteBuf; (AbstractByteBuf.java:250)  
```

and

```
    #0 io.netty.buffer.PoolArena.allocate(Lio/netty/buffer/PoolThreadCache;Lio/netty/buffer/PooledByteBuf;I)V (PoolArena.java:198)  
    #1 io.netty.buffer.PoolArena.allocate(Lio/netty/buffer/PoolThreadCache;II)Lio/netty/buffer/PooledByteBuf; (PoolArena.java:133)  
    #2 io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(II)Lio/netty/buffer/ByteBuf; (PooledByteBufAllocator.java:262)  
    #3 io.netty.buffer.AbstractByteBufAllocator.directBuffer(II)Lio/netty/buffer/ByteBuf; (AbstractByteBufAllocator.java:157)  
    #4 io.netty.buffer.AbstractByteBufAllocator.directBuffer(I)Lio/netty/buffer/ByteBuf; (AbstractByteBufAllocator.java:148)  
```

cc: @nmittler & @normanmaurer 
",https://github.com/netty/netty/issues/4829,1.0,0.0,0.0,49
161,"IllegalStateException in the selector loop when a connection attempt is cancelled.
`io.netty.testsuite.transport.socket.SocketConnectionAttemptTest.testConnectCancellation`
### Error Message

```
Expected: is <true>
     but: was <false>
```
### Stacktrace

```
java.lang.AssertionError: 
Expected: is <true>
     but: was <false>
    at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
    at org.junit.Assert.assertThat(Assert.java:865)
    at org.junit.Assert.assertThat(Assert.java:832)
    at io.netty.testsuite.transport.socket.SocketConnectionAttemptTest.testConnectCancellation(SocketConnectionAttemptTest.java:94)
```
### Standard Output

```
01:40:58.760 [main] DEBUG i.n.t.t.s.SocketConnectionAttemptTest - -Dio.netty.testsuite.badHost: 255.255.255.0
01:40:58.771 [main] INFO  i.n.t.t.s.SocketConnectionAttemptTest - Running: testConnectCancellation 1 of 2 with UnpooledByteBufAllocator
01:40:59.774 [testsuite-nio-worker-3-3] WARN  io.netty.channel.nio.NioEventLoop - Unexpected exception in the selector loop.
java.lang.IllegalStateException: complete already: DefaultChannelPromise@3f0cf5cb(failure(java.util.concurrent.CancellationException)
    at io.netty.util.concurrent.DefaultPromise.setFailure(DefaultPromise.java:401) ~[netty-common-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.channel.DefaultChannelPromise.setFailure(DefaultChannelPromise.java:87) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:240) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:502) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:452) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:346) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:101) [netty-common-4.0.13.Final-SNAPSHOT.jar:na]
    at java.lang.Thread.run(Thread.java:744) [na:1.7.0_45]
Caused by: java.net.SocketException: Network is unreachable
    at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) ~[na:1.7.0_45]
    at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:735) ~[na:1.7.0_45]
    at io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:191) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:228) ~[netty-transport-4.0.13.Final-SNAPSHOT.jar:na]
    ... 5 common frames omitted
```
",https://github.com/netty/netty/issues/1986,1.0,0.0,0.0,43
316,"Remove Duplicate Runtime Environment From Docs
<!--
For Security Vulnerabilities, please use https://pivotal.io/security#reporting
-->

### Summary

The Runtime Environment Section of the documentation is duplicated. We should remove the section in Servlets.",https://github.com/spring-projects/spring-security/issues/7980,1.0,2.0,2.0,44
